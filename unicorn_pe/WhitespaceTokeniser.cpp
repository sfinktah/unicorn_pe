// ReSharper disable CppJoinDeclarationAndAssignment
// #include "stdafx.h"
#include "WhitespaceTokeniser.h"
/*
 *  duk_config.h configuration header generated by genconfig.py.
 *
 *  Git commit: None
 *  Git describe: None
 *  Git branch: None
 *
 *  Platform: windows
 *
 *  Architecture: x64
 *
 *  Compiler: msvc
 *
 */

#if !defined(DUK_CONFIG_H_INCLUDED)
#define DUK_CONFIG_H_INCLUDED

/*
 *  Intermediate helper defines
 */

/* DLL build detection */
/* not configured for DLL build */
#undef DUK_F_DLL_BUILD

/* Windows, both 32-bit and 64-bit */
#if defined(_WIN32) || defined(WIN32) || defined(_WIN64) || defined(WIN64) || \
    defined(__WIN32__) || defined(__TOS_WIN__) || defined(__WINDOWS__)
#define DUK_F_WINDOWS
#if defined(_WIN64) || defined(WIN64)
#define DUK_F_WIN64
#else
#define DUK_F_WIN32
#endif
#endif

/* BCC (Bruce's C compiler): this is a "torture target" for compilation */
#if defined(__BCC__) || defined(__BCC_VERSION__)
#define DUK_F_BCC
#endif

/* Atari ST TOS.  __TOS__ defined by PureC.  No platform define in VBCC
 * apparently, so to use with VBCC user must define __TOS__ manually.
  */
#if defined(__TOS__)
#define DUK_F_TOS
#endif

/* stdint.h not available */
#if defined(DUK_F_WINDOWS) && defined(_MSC_VER)
#if (_MSC_VER < 1700)
/* VS2012+ has stdint.h, < VS2012 does not (but it's available for download). */
#define DUK_F_NO_STDINT_H
#endif
#endif
#if !defined(DUK_F_NO_STDINT_H) && (defined(DUK_F_TOS) || defined(DUK_F_BCC))
#define DUK_F_NO_STDINT_H
#endif

/* C++ */
#undef DUK_F_CPP
#if defined(__cplusplus)
#define DUK_F_CPP
#endif

/* C99 or above */
#undef DUK_F_C99
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
#define DUK_F_C99
#endif

/* ARM */
#if defined(__arm__) || defined(__thumb__) || defined(_ARM) || defined(_M_ARM) || defined(__aarch64__)
#define DUK_F_ARM
#if defined(__LP64__) || defined(_LP64) || defined(__arm64) || defined(__arm64__) || defined(__aarch64__)
#define DUK_F_ARM64
#else
#define DUK_F_ARM32
#endif
#endif

/* VBCC */
#if defined(__VBCC__)
#define DUK_F_VBCC
#endif

/* AIX */
#if defined(_AIX)
/* defined(__xlc__) || defined(__IBMC__): works but too wide */
#define DUK_F_AIX
#endif

/* illumos / Solaris */
#if defined(__sun) && defined(__SVR4)
#define DUK_F_SUN
#if defined(__SUNPRO_C) && (__SUNPRO_C < 0x550)
#define DUK_F_OLD_SOLARIS
/* Defines _ILP32 / _LP64 required by DUK_F_X86/DUK_F_X64.  Platforms
 * are processed before architectures, so this happens before the
 * DUK_F_X86/DUK_F_X64 detection is emitted.
 */
#include <sys/isa_defs.h>
#endif
#endif

/* PowerPC */
#if defined(__powerpc) || defined(__powerpc__) || defined(__PPC__)
#define DUK_F_PPC
#if defined(__PPC64__) || defined(__LP64__) || defined(_LP64)
#define DUK_F_PPC64
#else
#define DUK_F_PPC32
#endif
#endif

/* Motorola 68K.  Not defined by VBCC, so user must define one of these
 * manually when using VBCC.
 */
#if defined(__m68k__) || defined(M68000) || defined(__MC68K__)
#define DUK_F_M68K
#endif

/* Intel x86 (32-bit), x64 (64-bit) or x32 (64-bit but 32-bit pointers),
 * define only one of DUK_F_X86, DUK_F_X64, DUK_F_X32.
 * https://sites.google.com/site/x32abi/
 *
 * With DUK_F_OLD_SOLARIS the <sys/isa_defs.h> header must be included
 * before this.
 */
#if defined(__amd64__) || defined(__amd64) || \
    defined(__x86_64__) || defined(__x86_64) || \
    defined(_M_X64) || defined(_M_AMD64)
#if defined(__ILP32__) || defined(_ILP32)
#define DUK_F_X32
#else
#define DUK_F_X64
#endif
#elif defined(i386) || defined(__i386) || defined(__i386__) || \
      defined(__i486__) || defined(__i586__) || defined(__i686__) || \
      defined(__IA32__) || defined(_M_IX86) || defined(__X86__) || \
      defined(_X86_) || defined(__THW_INTEL__) || defined(__I86__)
#if defined(__LP64__) || defined(_LP64)
/* This should not really happen, but would indicate x64. */
#define DUK_F_X64
#else
#define DUK_F_X86
#endif
#endif

/* HPUX */
#if defined(__hpux)
#define DUK_F_HPUX
#if defined(__ia64)
#define DUK_F_HPUX_ITANIUM
#endif
#endif

/* AmigaOS.  Neither AMIGA nor __amigaos__ is defined on VBCC, so user must
 * define 'AMIGA' manually when using VBCC.
 */
#if defined(AMIGA) || defined(__amigaos__)
#define DUK_F_AMIGAOS
#endif

/* MSVC */
#if defined(_MSC_VER)
/* MSVC preprocessor defines: http://msdn.microsoft.com/en-us/library/b0084kay.aspx
 * _MSC_FULL_VER includes the build number, but it has at least two formats, see e.g.
 * BOOST_MSVC_FULL_VER in http://www.boost.org/doc/libs/1_52_0/boost/config/compiler/visualc.hpp
 */
#define DUK_F_MSVC
#if defined(_MSC_FULL_VER)
#if (_MSC_FULL_VER > 100000000)
#define DUK_F_MSVC_FULL_VER _MSC_FULL_VER
#else
#define DUK_F_MSCV_FULL_VER (_MSC_FULL_VER * 10)
#endif
#endif
#endif  /* _MSC_VER */

/* MinGW.  Also GCC flags (DUK_F_GCC) are enabled now. */
#if defined(__MINGW32__) || defined(__MINGW64__)
#define DUK_F_MINGW
#endif

/* FreeBSD */
#if defined(__FreeBSD__) || defined(__FreeBSD)
#define DUK_F_FREEBSD
#endif

#if defined(ANDROID) || defined(__ANDROID__)
#define DUK_F_ANDROID
#endif

/* Atari Mint */
#if defined(__MINT__)
#define DUK_F_MINT
#endif

/* Clang */
#if defined(__clang__)
#define DUK_F_CLANG
#endif

/* GCC.  Clang also defines __GNUC__ so don't detect GCC if using Clang. */
#if defined(__GNUC__) && !defined(__clang__) && !defined(DUK_F_CLANG)
#define DUK_F_GCC
#if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
/* Convenience, e.g. gcc 4.5.1 == 40501; http://stackoverflow.com/questions/6031819/emulating-gccs-builtin-unreachable */
#define DUK_F_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)
#else
#error cannot figure out gcc version
#endif
#endif

/* NetBSD */
#if defined(__NetBSD__) || defined(__NetBSD)
#define DUK_F_NETBSD
#endif

/* C++11 or above */
#undef DUK_F_CPP11
#if defined(__cplusplus) && (__cplusplus >= 201103L)
#define DUK_F_CPP11
#endif

/*
 *  Platform: windows
 */

/* Workaround for older C++ compilers before including <inttypes.h>,
 * see e.g.: https://sourceware.org/bugzilla/show_bug.cgi?id=15366
 */
#if defined(__cplusplus) && !defined(__STDC_LIMIT_MACROS)
#define __STDC_LIMIT_MACROS
#endif
#if defined(__cplusplus) && !defined(__STDC_CONSTANT_MACROS)
#define __STDC_CONSTANT_MACROS
#endif

/* Windows version can't obviously be determined at compile time,
 * but _WIN32_WINNT indicates the minimum version targeted:
 * - https://msdn.microsoft.com/en-us/library/6sehtctf.aspx
 */

/* Initial fix: disable secure CRT related warnings when compiling Duktape
 * itself (must be defined before including Windows headers).  Don't define
 * for user code including duktape.h.
 */
#if defined(DUK_COMPILING_DUKTAPE) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

/* Windows 32-bit and 64-bit are currently the same. */
/* MSVC does not have sys/param.h */

#if defined(DUK_COMPILING_DUKTAPE)
/* Only include when compiling Duktape to avoid polluting application build
 * with a lot of unnecessary defines.
 */
#include <windows.h>
#endif

/* GetSystemTimePreciseAsFileTime() available from Windows 8:
 * https://msdn.microsoft.com/en-us/library/windows/desktop/hh706895(v=vs.85).aspx
 */
#if defined(DUK_USE_DATE_NOW_WINDOWS_SUBMS) || defined(DUK_USE_DATE_NOW_WINDOWS)
/* User forced provider. */
#else
#if defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0602)
#define DUK_USE_DATE_NOW_WINDOWS_SUBMS
#else
#define DUK_USE_DATE_NOW_WINDOWS
#endif
#endif

#define DUK_USE_DATE_TZO_WINDOWS

/* Note: PRS and FMT are intentionally left undefined for now.  This means
 * there is no platform specific date parsing/formatting but there is still
 * the ISO 8601 standard format.
 */

/* QueryPerformanceCounter() may go backwards in Windows XP, so enable for
 * Vista and later: https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx#qpc_support_in_windows_versions
 */
#if !defined(DUK_USE_GET_MONOTONIC_TIME_WINDOWS_QPC) && \
    defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0600)
#define DUK_USE_GET_MONOTONIC_TIME_WINDOWS_QPC
#endif

#define DUK_USE_OS_STRING "windows"

/* On Windows, assume we're little endian.  Even Itanium which has a
 * configurable endianness runs little endian in Windows.
 */
#if !defined(DUK_USE_BYTEORDER)
#define DUK_USE_BYTEORDER 1
#endif

/* Shared includes: C89 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>  /* varargs */
#include <setjmp.h>
#include <stddef.h>  /* e.g. ptrdiff_t */
#include <math.h>
#include <limits.h>

/* date.h is omitted, and included per platform */

/* Shared includes: stdint.h is C99 */
#if defined(DUK_F_NO_STDINT_H)
/* stdint.h not available */
#else
/* Technically C99 (C++11) but found in many systems.  On some systems
 * __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS must be defined before
 * including stdint.h (see above).
 */
#include <stdint.h>
#endif

/* <exception> is only included if needed, based on DUK_USE_xxx flags. */

/*
 *  Architecture: x64
 */

#define DUK_USE_ARCH_STRING "x64"
#if !defined(DUK_USE_BYTEORDER)
#define DUK_USE_BYTEORDER 1
#endif
#undef DUK_USE_PACKED_TVAL
#define DUK_F_PACKED_TVAL_PROVIDED

/*
 *  Compiler: msvc
 */

/* http://msdn.microsoft.com/en-us/library/aa235362(VS.60).aspx */
#define DUK_NORETURN(decl)  __declspec(noreturn) decl

/* XXX: DUK_UNREACHABLE for msvc? */

#undef DUK_USE_BRANCH_HINTS

/* XXX: DUK_LIKELY, DUK_UNLIKELY for msvc? */
/* XXX: DUK_NOINLINE, DUK_INLINE, DUK_ALWAYS_INLINE for msvc? */

#if defined(DUK_F_DLL_BUILD) && defined(DUK_F_WINDOWS)
/* MSVC dllexport/dllimport: appropriate __declspec depends on whether we're
 * compiling Duktape or the application.
 */
#if defined(DUK_COMPILING_DUKTAPE)
#define DUK_EXTERNAL_DECL  extern __declspec(dllexport)
#define DUK_EXTERNAL       __declspec(dllexport)
#else
#define DUK_EXTERNAL_DECL  extern __declspec(dllimport)
#define DUK_EXTERNAL       should_not_happen
#endif
#if defined(DUK_SINGLE_FILE)
#define DUK_INTERNAL_DECL  static
#define DUK_INTERNAL       static
#else
#define DUK_INTERNAL_DECL  extern
#define DUK_INTERNAL       /*empty*/
#endif
#define DUK_LOCAL_DECL     static
#define DUK_LOCAL          static
#endif

#if defined(DUK_F_CPP)
#define DUK_USE_COMPILER_STRING "msvc++"
#else
#define DUK_USE_COMPILER_STRING "msvc"
#endif

#undef DUK_USE_VARIADIC_MACROS
#if defined(DUK_F_C99)
#define DUK_USE_VARIADIC_MACROS
#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
/* VS2005+ should have variadic macros even when they're not C99. */
#define DUK_USE_VARIADIC_MACROS
#endif

#undef DUK_USE_UNION_INITIALIZERS
#if defined(_MSC_VER) && (_MSC_VER >= 1800)
/* VS2013+ supports union initializers but there's a bug involving union-inside-struct:
 * https://connect.microsoft.com/VisualStudio/feedback/details/805981
 * The bug was fixed (at least) in VS2015 so check for VS2015 for now:
 * https://blogs.msdn.microsoft.com/vcblog/2015/07/01/c-compiler-front-end-fixes-in-vs2015/
 * Manually tested using VS2013, CL reports 18.00.31101, so enable for VS2013 too.
 */
#define DUK_USE_UNION_INITIALIZERS
#endif

#undef DUK_USE_FLEX_C99
#undef DUK_USE_FLEX_ZEROSIZE
#undef DUK_USE_FLEX_ONESIZE
#if defined(DUK_F_C99)
#define DUK_USE_FLEX_C99
#else
#define DUK_USE_FLEX_ZEROSIZE
#endif

#undef DUK_USE_GCC_PRAGMAS

#define DUK_USE_PACK_MSVC_PRAGMA

/* These have been tested from VS2008 onwards; may work in older VS versions
 * too but not enabled by default.
 */
#if defined(_MSC_VER) && (_MSC_VER >= 1500)
#define DUK_NOINLINE        __declspec(noinline)
#define DUK_INLINE          __inline
#define DUK_ALWAYS_INLINE   __forceinline
#endif

#if defined(_MSC_VER) && (_MSC_VER >= 1900)
#define DUK_SNPRINTF     snprintf
#define DUK_VSNPRINTF    vsnprintf
#else
/* (v)snprintf() is missing before MSVC 2015.  Note that _(v)snprintf() does
 * NOT NUL terminate on truncation, but Duktape code never assumes that.
 * http://stackoverflow.com/questions/2915672/snprintf-and-visual-studio-2010
 */
#define DUK_SNPRINTF     _snprintf
#define DUK_VSNPRINTF    _vsnprintf
#endif

/* Avoid warning when doing DUK_UNREF(some_function). */
#if defined(_MSC_VER) && (_MSC_VER < 1500)
#pragma warning(disable: 4100 4101 4550 4551)
#define DUK_UNREF(x)
#else
#define DUK_UNREF(x)  do { __pragma(warning(suppress:4100 4101 4550 4551)) (x); } while (0)
#endif

/* Older versions of MSVC don't support the LL/ULL suffix. */
#define DUK_U64_CONSTANT(x) x##ui64
#define DUK_I64_CONSTANT(x) x##i64

/* uclibc */
#if defined(__UCLIBC__)
#define DUK_F_UCLIBC
#endif

/*
 *  Wrapper typedefs and constants for integer types, also sanity check types.
 *
 *  C99 typedefs are quite good but not always available, and we want to avoid
 *  forcibly redefining the C99 typedefs.  So, there are Duktape wrappers for
 *  all C99 typedefs and Duktape code should only use these typedefs.  Type
 *  detection when C99 is not supported is best effort and may end up detecting
 *  some types incorrectly.
 *
 *  Pointer sizes are a portability problem: pointers to different types may
 *  have a different size and function pointers are very difficult to manage
 *  portably.
 *
 *  http://en.wikipedia.org/wiki/C_data_types#Fixed-width_integer_types
 *
 *  Note: there's an interesting corner case when trying to define minimum
 *  signed integer value constants which leads to the current workaround of
 *  defining e.g. -0x80000000 as (-0x7fffffffL - 1L).  See doc/code-issues.txt
 *  for a longer discussion.
 *
 *  Note: avoid typecasts and computations in macro integer constants as they
 *  can then no longer be used in macro relational expressions (such as
 *  #if DUK_SIZE_MAX < 0xffffffffUL).  There is internal code which relies on
 *  being able to compare DUK_SIZE_MAX against a limit.
 */

/* XXX: add feature options to force basic types from outside? */

#if !defined(INT_MAX)
#error INT_MAX not defined
#endif

/* Check that architecture is two's complement, standard C allows e.g.
 * INT_MIN to be -2**31+1 (instead of -2**31).
 */
#if defined(INT_MAX) && defined(INT_MIN)
#if INT_MAX != -(INT_MIN + 1)
#error platform does not seem complement of two
#endif
#else
#error cannot check complement of two
#endif

/* Pointer size determination based on __WORDSIZE or architecture when
 * that's not available.
 */
#if defined(DUK_F_X86) || defined(DUK_F_X32) || \
    defined(DUK_F_M68K) || defined(DUK_F_PPC32) || \
    defined(DUK_F_BCC) || \
    (defined(__WORDSIZE) && (__WORDSIZE == 32)) || \
    ((defined(DUK_F_OLD_SOLARIS) || defined(DUK_F_AIX) || \
      defined(DUK_F_HPUX)) && defined(_ILP32)) || \
    defined(DUK_F_ARM32)
#define DUK_F_32BIT_PTRS
#elif defined(DUK_F_X64) || \
      (defined(__WORDSIZE) && (__WORDSIZE == 64)) || \
   ((defined(DUK_F_OLD_SOLARIS) || defined(DUK_F_AIX) || \
     defined(DUK_F_HPUX)) && defined(_LP64)) || \
    defined(DUK_F_ARM64)
#define DUK_F_64BIT_PTRS
#else
/* not sure, not needed with C99 anyway */
#endif

/* Intermediate define for 'have inttypes.h' */
#undef DUK_F_HAVE_INTTYPES
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
    !(defined(DUK_F_AMIGAOS) && defined(DUK_F_VBCC))
/* vbcc + AmigaOS has C99 but no inttypes.h */
#define DUK_F_HAVE_INTTYPES
#elif defined(__cplusplus) && (__cplusplus >= 201103L)
/* C++11 apparently ratified stdint.h */
#define DUK_F_HAVE_INTTYPES
#endif

/* Basic integer typedefs and limits, preferably from inttypes.h, otherwise
 * through automatic detection.
 */
#if defined(DUK_F_HAVE_INTTYPES)
/* C99 or compatible */

#define DUK_F_HAVE_64BIT
#include <inttypes.h>

typedef uint8_t duk_uint8_t;
typedef int8_t duk_int8_t;
typedef uint16_t duk_uint16_t;
typedef int16_t duk_int16_t;
typedef uint32_t duk_uint32_t;
typedef int32_t duk_int32_t;
typedef uint64_t duk_uint64_t;
typedef int64_t duk_int64_t;
typedef uint_least8_t duk_uint_least8_t;
typedef int_least8_t duk_int_least8_t;
typedef uint_least16_t duk_uint_least16_t;
typedef int_least16_t duk_int_least16_t;
typedef uint_least32_t duk_uint_least32_t;
typedef int_least32_t duk_int_least32_t;
typedef uint_least64_t duk_uint_least64_t;
typedef int_least64_t duk_int_least64_t;
typedef uint_fast8_t duk_uint_fast8_t;
typedef int_fast8_t duk_int_fast8_t;
typedef uint_fast16_t duk_uint_fast16_t;
typedef int_fast16_t duk_int_fast16_t;
typedef uint_fast32_t duk_uint_fast32_t;
typedef int_fast32_t duk_int_fast32_t;
typedef uint_fast64_t duk_uint_fast64_t;
typedef int_fast64_t duk_int_fast64_t;
typedef uintptr_t duk_uintptr_t;
typedef intptr_t duk_intptr_t;
typedef uintmax_t duk_uintmax_t;
typedef intmax_t duk_intmax_t;

#define DUK_UINT8_MIN         0
#define DUK_UINT8_MAX         UINT8_MAX
#define DUK_INT8_MIN          INT8_MIN
#define DUK_INT8_MAX          INT8_MAX
#define DUK_UINT_LEAST8_MIN   0
#define DUK_UINT_LEAST8_MAX   UINT_LEAST8_MAX
#define DUK_INT_LEAST8_MIN    INT_LEAST8_MIN
#define DUK_INT_LEAST8_MAX    INT_LEAST8_MAX
#define DUK_UINT_FAST8_MIN    0
#define DUK_UINT_FAST8_MAX    UINT_FAST8_MAX
#define DUK_INT_FAST8_MIN     INT_FAST8_MIN
#define DUK_INT_FAST8_MAX     INT_FAST8_MAX
#define DUK_UINT16_MIN        0
#define DUK_UINT16_MAX        UINT16_MAX
#define DUK_INT16_MIN         INT16_MIN
#define DUK_INT16_MAX         INT16_MAX
#define DUK_UINT_LEAST16_MIN  0
#define DUK_UINT_LEAST16_MAX  UINT_LEAST16_MAX
#define DUK_INT_LEAST16_MIN   INT_LEAST16_MIN
#define DUK_INT_LEAST16_MAX   INT_LEAST16_MAX
#define DUK_UINT_FAST16_MIN   0
#define DUK_UINT_FAST16_MAX   UINT_FAST16_MAX
#define DUK_INT_FAST16_MIN    INT_FAST16_MIN
#define DUK_INT_FAST16_MAX    INT_FAST16_MAX
#define DUK_UINT32_MIN        0
#define DUK_UINT32_MAX        UINT32_MAX
#define DUK_INT32_MIN         INT32_MIN
#define DUK_INT32_MAX         INT32_MAX
#define DUK_UINT_LEAST32_MIN  0
#define DUK_UINT_LEAST32_MAX  UINT_LEAST32_MAX
#define DUK_INT_LEAST32_MIN   INT_LEAST32_MIN
#define DUK_INT_LEAST32_MAX   INT_LEAST32_MAX
#define DUK_UINT_FAST32_MIN   0
#define DUK_UINT_FAST32_MAX   UINT_FAST32_MAX
#define DUK_INT_FAST32_MIN    INT_FAST32_MIN
#define DUK_INT_FAST32_MAX    INT_FAST32_MAX
#define DUK_UINT64_MIN        0
#define DUK_UINT64_MAX        UINT64_MAX
#define DUK_INT64_MIN         INT64_MIN
#define DUK_INT64_MAX         INT64_MAX
#define DUK_UINT_LEAST64_MIN  0
#define DUK_UINT_LEAST64_MAX  UINT_LEAST64_MAX
#define DUK_INT_LEAST64_MIN   INT_LEAST64_MIN
#define DUK_INT_LEAST64_MAX   INT_LEAST64_MAX
#define DUK_UINT_FAST64_MIN   0
#define DUK_UINT_FAST64_MAX   UINT_FAST64_MAX
#define DUK_INT_FAST64_MIN    INT_FAST64_MIN
#define DUK_INT_FAST64_MAX    INT_FAST64_MAX

#define DUK_UINTPTR_MIN       0
#define DUK_UINTPTR_MAX       UINTPTR_MAX
#define DUK_INTPTR_MIN        INTPTR_MIN
#define DUK_INTPTR_MAX        INTPTR_MAX

#define DUK_UINTMAX_MIN       0
#define DUK_UINTMAX_MAX       UINTMAX_MAX
#define DUK_INTMAX_MIN        INTMAX_MIN
#define DUK_INTMAX_MAX        INTMAX_MAX

#define DUK_SIZE_MIN          0
#define DUK_SIZE_MAX          SIZE_MAX
#undef DUK_SIZE_MAX_COMPUTED

#else  /* C99 types */

/* When C99 types are not available, we use heuristic detection to get
 * the basic 8, 16, 32, and (possibly) 64 bit types.  The fast/least
 * types are then assumed to be exactly the same for now: these could
 * be improved per platform but C99 types are very often now available.
 * 64-bit types are not available on all platforms; this is OK at least
 * on 32-bit platforms.
 *
 * This detection code is necessarily a bit hacky and can provide typedefs
 * and defines that won't work correctly on some exotic platform.
 */

#if (defined(CHAR_BIT) && (CHAR_BIT == 8)) || \
    (defined(UCHAR_MAX) && (UCHAR_MAX == 255))
typedef unsigned char duk_uint8_t;
typedef signed char duk_int8_t;
#else
#error cannot detect 8-bit type
#endif

#if defined(USHRT_MAX) && (USHRT_MAX == 65535UL)
typedef unsigned short duk_uint16_t;
typedef signed short duk_int16_t;
#elif defined(UINT_MAX) && (UINT_MAX == 65535UL)
/* On some platforms int is 16-bit but long is 32-bit (e.g. PureC) */
typedef unsigned int duk_uint16_t;
typedef signed int duk_int16_t;
#else
#error cannot detect 16-bit type
#endif

#if defined(UINT_MAX) && (UINT_MAX == 4294967295UL)
typedef unsigned int duk_uint32_t;
typedef signed int duk_int32_t;
#elif defined(ULONG_MAX) && (ULONG_MAX == 4294967295UL)
/* On some platforms int is 16-bit but long is 32-bit (e.g. PureC) */
typedef unsigned long duk_uint32_t;
typedef signed long duk_int32_t;
#else
#error cannot detect 32-bit type
#endif

/* 64-bit type detection is a bit tricky.
 *
 * ULLONG_MAX is a standard define.  __LONG_LONG_MAX__ and __ULONG_LONG_MAX__
 * are used by at least GCC (even if system headers don't provide ULLONG_MAX).
 * Some GCC variants may provide __LONG_LONG_MAX__ but not __ULONG_LONG_MAX__.
 *
 * ULL / LL constants are rejected / warned about by some compilers, even if
 * the compiler has a 64-bit type and the compiler/system headers provide an
 * unsupported constant (ULL/LL)!  Try to avoid using ULL / LL constants.
 * As a side effect we can only check that e.g. ULONG_MAX is larger than 32
 * bits but can't be sure it is exactly 64 bits.  Self tests will catch such
 * cases.
 */
#undef DUK_F_HAVE_64BIT
#if !defined(DUK_F_HAVE_64BIT) && defined(ULONG_MAX)
#if (ULONG_MAX > 4294967295UL)
#define DUK_F_HAVE_64BIT
typedef unsigned long duk_uint64_t;
typedef signed long duk_int64_t;
#endif
#endif
#if !defined(DUK_F_HAVE_64BIT) && defined(ULLONG_MAX)
#if (ULLONG_MAX > 4294967295UL)
#define DUK_F_HAVE_64BIT
typedef unsigned long long duk_uint64_t;
typedef signed long long duk_int64_t;
#endif
#endif
#if !defined(DUK_F_HAVE_64BIT) && defined(__ULONG_LONG_MAX__)
#if (__ULONG_LONG_MAX__ > 4294967295UL)
#define DUK_F_HAVE_64BIT
typedef unsigned long long duk_uint64_t;
typedef signed long long duk_int64_t;
#endif
#endif
#if !defined(DUK_F_HAVE_64BIT) && defined(__LONG_LONG_MAX__)
#if (__LONG_LONG_MAX__ > 2147483647L)
#define DUK_F_HAVE_64BIT
typedef unsigned long long duk_uint64_t;
typedef signed long long duk_int64_t;
#endif
#endif
#if !defined(DUK_F_HAVE_64BIT) && defined(DUK_F_MINGW)
#define DUK_F_HAVE_64BIT
typedef unsigned long duk_uint64_t;
typedef signed long duk_int64_t;
#endif
#if !defined(DUK_F_HAVE_64BIT) && defined(DUK_F_MSVC)
#define DUK_F_HAVE_64BIT
typedef unsigned __int64 duk_uint64_t;
typedef signed __int64 duk_int64_t;
#endif
#if !defined(DUK_F_HAVE_64BIT)
/* cannot detect 64-bit type, not always needed so don't error */
#endif

typedef duk_uint8_t duk_uint_least8_t;
typedef duk_int8_t duk_int_least8_t;
typedef duk_uint16_t duk_uint_least16_t;
typedef duk_int16_t duk_int_least16_t;
typedef duk_uint32_t duk_uint_least32_t;
typedef duk_int32_t duk_int_least32_t;
typedef duk_uint8_t duk_uint_fast8_t;
typedef duk_int8_t duk_int_fast8_t;
typedef duk_uint16_t duk_uint_fast16_t;
typedef duk_int16_t duk_int_fast16_t;
typedef duk_uint32_t duk_uint_fast32_t;
typedef duk_int32_t duk_int_fast32_t;
#if defined(DUK_F_HAVE_64BIT)
typedef duk_uint64_t duk_uint_least64_t;
typedef duk_int64_t duk_int_least64_t;
typedef duk_uint64_t duk_uint_fast64_t;
typedef duk_int64_t duk_int_fast64_t;
#endif
#if defined(DUK_F_HAVE_64BIT)
typedef duk_uint64_t duk_uintmax_t;
typedef duk_int64_t duk_intmax_t;
#else
typedef duk_uint32_t duk_uintmax_t;
typedef duk_int32_t duk_intmax_t;
#endif

/* Note: the funny looking computations for signed minimum 16-bit, 32-bit, and
 * 64-bit values are intentional as the obvious forms (e.g. -0x80000000L) are
 * -not- portable.  See code-issues.txt for a detailed discussion.
 */
#define DUK_UINT8_MIN         0UL
#define DUK_UINT8_MAX         0xffUL
#define DUK_INT8_MIN          (-0x80L)
#define DUK_INT8_MAX          0x7fL
#define DUK_UINT_LEAST8_MIN   0UL
#define DUK_UINT_LEAST8_MAX   0xffUL
#define DUK_INT_LEAST8_MIN    (-0x80L)
#define DUK_INT_LEAST8_MAX    0x7fL
#define DUK_UINT_FAST8_MIN    0UL
#define DUK_UINT_FAST8_MAX    0xffUL
#define DUK_INT_FAST8_MIN     (-0x80L)
#define DUK_INT_FAST8_MAX     0x7fL
#define DUK_UINT16_MIN        0UL
#define DUK_UINT16_MAX        0xffffUL
#define DUK_INT16_MIN         (-0x7fffL - 1L)
#define DUK_INT16_MAX         0x7fffL
#define DUK_UINT_LEAST16_MIN  0UL
#define DUK_UINT_LEAST16_MAX  0xffffUL
#define DUK_INT_LEAST16_MIN   (-0x7fffL - 1L)
#define DUK_INT_LEAST16_MAX   0x7fffL
#define DUK_UINT_FAST16_MIN   0UL
#define DUK_UINT_FAST16_MAX   0xffffUL
#define DUK_INT_FAST16_MIN    (-0x7fffL - 1L)
#define DUK_INT_FAST16_MAX    0x7fffL
#define DUK_UINT32_MIN        0UL
#define DUK_UINT32_MAX        0xffffffffUL
#define DUK_INT32_MIN         (-0x7fffffffL - 1L)
#define DUK_INT32_MAX         0x7fffffffL
#define DUK_UINT_LEAST32_MIN  0UL
#define DUK_UINT_LEAST32_MAX  0xffffffffUL
#define DUK_INT_LEAST32_MIN   (-0x7fffffffL - 1L)
#define DUK_INT_LEAST32_MAX   0x7fffffffL
#define DUK_UINT_FAST32_MIN   0UL
#define DUK_UINT_FAST32_MAX   0xffffffffUL
#define DUK_INT_FAST32_MIN    (-0x7fffffffL - 1L)
#define DUK_INT_FAST32_MAX    0x7fffffffL

/* 64-bit constants.  Since LL / ULL constants are not always available,
 * use computed values.  These values can't be used in preprocessor
 * comparisons; flag them as such.
 */
#if defined(DUK_F_HAVE_64BIT)
#define DUK_UINT64_MIN        ((duk_uint64_t) 0)
#define DUK_UINT64_MAX        ((duk_uint64_t) -1)
#define DUK_INT64_MIN         ((duk_int64_t) (~(DUK_UINT64_MAX >> 1)))
#define DUK_INT64_MAX         ((duk_int64_t) (DUK_UINT64_MAX >> 1))
#define DUK_UINT_LEAST64_MIN  DUK_UINT64_MIN
#define DUK_UINT_LEAST64_MAX  DUK_UINT64_MAX
#define DUK_INT_LEAST64_MIN   DUK_INT64_MIN
#define DUK_INT_LEAST64_MAX   DUK_INT64_MAX
#define DUK_UINT_FAST64_MIN   DUK_UINT64_MIN
#define DUK_UINT_FAST64_MAX   DUK_UINT64_MAX
#define DUK_INT_FAST64_MIN    DUK_INT64_MIN
#define DUK_INT_FAST64_MAX    DUK_INT64_MAX
#define DUK_UINT64_MIN_COMPUTED
#define DUK_UINT64_MAX_COMPUTED
#define DUK_INT64_MIN_COMPUTED
#define DUK_INT64_MAX_COMPUTED
#define DUK_UINT_LEAST64_MIN_COMPUTED
#define DUK_UINT_LEAST64_MAX_COMPUTED
#define DUK_INT_LEAST64_MIN_COMPUTED
#define DUK_INT_LEAST64_MAX_COMPUTED
#define DUK_UINT_FAST64_MIN_COMPUTED
#define DUK_UINT_FAST64_MAX_COMPUTED
#define DUK_INT_FAST64_MIN_COMPUTED
#define DUK_INT_FAST64_MAX_COMPUTED
#endif

#if defined(DUK_F_HAVE_64BIT)
#define DUK_UINTMAX_MIN       DUK_UINT64_MIN
#define DUK_UINTMAX_MAX       DUK_UINT64_MAX
#define DUK_INTMAX_MIN        DUK_INT64_MIN
#define DUK_INTMAX_MAX        DUK_INT64_MAX
#define DUK_UINTMAX_MIN_COMPUTED
#define DUK_UINTMAX_MAX_COMPUTED
#define DUK_INTMAX_MIN_COMPUTED
#define DUK_INTMAX_MAX_COMPUTED
#else
#define DUK_UINTMAX_MIN       0UL
#define DUK_UINTMAX_MAX       0xffffffffUL
#define DUK_INTMAX_MIN        (-0x7fffffffL - 1L)
#define DUK_INTMAX_MAX        0x7fffffffL
#endif

/* This detection is not very reliable. */
#if defined(DUK_F_32BIT_PTRS)
typedef duk_int32_t duk_intptr_t;
typedef duk_uint32_t duk_uintptr_t;
#define DUK_UINTPTR_MIN       DUK_UINT32_MIN
#define DUK_UINTPTR_MAX       DUK_UINT32_MAX
#define DUK_INTPTR_MIN        DUK_INT32_MIN
#define DUK_INTPTR_MAX        DUK_INT32_MAX
#elif defined(DUK_F_64BIT_PTRS) && defined(DUK_F_HAVE_64BIT)
typedef duk_int64_t duk_intptr_t;
typedef duk_uint64_t duk_uintptr_t;
#define DUK_UINTPTR_MIN       DUK_UINT64_MIN
#define DUK_UINTPTR_MAX       DUK_UINT64_MAX
#define DUK_INTPTR_MIN        DUK_INT64_MIN
#define DUK_INTPTR_MAX        DUK_INT64_MAX
#define DUK_UINTPTR_MIN_COMPUTED
#define DUK_UINTPTR_MAX_COMPUTED
#define DUK_INTPTR_MIN_COMPUTED
#define DUK_INTPTR_MAX_COMPUTED
#else
#error cannot determine intptr type
#endif

/* SIZE_MAX may be missing so use an approximate value for it. */
#undef DUK_SIZE_MAX_COMPUTED
#if !defined(SIZE_MAX)
#define DUK_SIZE_MAX_COMPUTED
#define SIZE_MAX              ((size_t) (-1))
#endif
#define DUK_SIZE_MIN          0
#define DUK_SIZE_MAX          SIZE_MAX

#endif  /* C99 types */

/* A few types are assumed to always exist. */
typedef size_t duk_size_t;
typedef ptrdiff_t duk_ptrdiff_t;

/* The best type for an "all around int" in Duktape internals is "at least
 * 32 bit signed integer" which is most convenient.  Same for unsigned type.
 * Prefer 'int' when large enough, as it is almost always a convenient type.
 */
#if defined(UINT_MAX) && (UINT_MAX >= 0xffffffffUL)
typedef int duk_int_t;
typedef unsigned int duk_uint_t;
#define DUK_INT_MIN           INT_MIN
#define DUK_INT_MAX           INT_MAX
#define DUK_UINT_MIN          0
#define DUK_UINT_MAX          UINT_MAX
#else
typedef duk_int_fast32_t duk_int_t;
typedef duk_uint_fast32_t duk_uint_t;
#define DUK_INT_MIN           DUK_INT_FAST32_MIN
#define DUK_INT_MAX           DUK_INT_FAST32_MAX
#define DUK_UINT_MIN          DUK_UINT_FAST32_MIN
#define DUK_UINT_MAX          DUK_UINT_FAST32_MAX
#endif

/* Same as 'duk_int_t' but guaranteed to be a 'fast' variant if this
 * distinction matters for the CPU.  These types are used mainly in the
 * executor where it might really matter.
 */
typedef duk_int_fast32_t duk_int_fast_t;
typedef duk_uint_fast32_t duk_uint_fast_t;
#define DUK_INT_FAST_MIN      DUK_INT_FAST32_MIN
#define DUK_INT_FAST_MAX      DUK_INT_FAST32_MAX
#define DUK_UINT_FAST_MIN     DUK_UINT_FAST32_MIN
#define DUK_UINT_FAST_MAX     DUK_UINT_FAST32_MAX

/* Small integers (16 bits or more) can fall back to the 'int' type, but
 * have a typedef so they are marked "small" explicitly.
 */
typedef int duk_small_int_t;
typedef unsigned int duk_small_uint_t;
#define DUK_SMALL_INT_MIN     INT_MIN
#define DUK_SMALL_INT_MAX     INT_MAX
#define DUK_SMALL_UINT_MIN    0
#define DUK_SMALL_UINT_MAX    UINT_MAX

/* Fast variants of small integers, again for really fast paths like the
 * executor.
 */
typedef duk_int_fast16_t duk_small_int_fast_t;
typedef duk_uint_fast16_t duk_small_uint_fast_t;
#define DUK_SMALL_INT_FAST_MIN    DUK_INT_FAST16_MIN
#define DUK_SMALL_INT_FAST_MAX    DUK_INT_FAST16_MAX
#define DUK_SMALL_UINT_FAST_MIN   DUK_UINT_FAST16_MIN
#define DUK_SMALL_UINT_FAST_MAX   DUK_UINT_FAST16_MAX

/* Boolean values are represented with the platform 'unsigned int'. */
typedef duk_small_uint_t duk_bool_t;
#define DUK_BOOL_MIN              DUK_SMALL_UINT_MIN
#define DUK_BOOL_MAX              DUK_SMALL_UINT_MAX

/* Index values must have at least 32-bit signed range. */
typedef duk_int_t duk_idx_t;
#define DUK_IDX_MIN               DUK_INT_MIN
#define DUK_IDX_MAX               DUK_INT_MAX

/* Unsigned index variant. */
typedef duk_uint_t duk_uidx_t;
#define DUK_UIDX_MIN              DUK_UINT_MIN
#define DUK_UIDX_MAX              DUK_UINT_MAX

/* Array index values, could be exact 32 bits.
 * Currently no need for signed duk_arridx_t.
 */
typedef duk_uint_t duk_uarridx_t;
#define DUK_UARRIDX_MIN           DUK_UINT_MIN
#define DUK_UARRIDX_MAX           DUK_UINT_MAX

/* Duktape/C function return value, platform int is enough for now to
 * represent 0, 1, or negative error code.  Must be compatible with
 * assigning truth values (e.g. duk_ret_t rc = (foo == bar);).
 */
typedef duk_small_int_t duk_ret_t;
#define DUK_RET_MIN               DUK_SMALL_INT_MIN
#define DUK_RET_MAX               DUK_SMALL_INT_MAX

/* Error codes are represented with platform int.  High bits are used
 * for flags and such, so 32 bits are needed.
 */
typedef duk_int_t duk_errcode_t;
#define DUK_ERRCODE_MIN           DUK_INT_MIN
#define DUK_ERRCODE_MAX           DUK_INT_MAX

/* Codepoint type.  Must be 32 bits or more because it is used also for
 * internal codepoints.  The type is signed because negative codepoints
 * are used as internal markers (e.g. to mark EOF or missing argument).
 * (X)UTF-8/CESU-8 encode/decode take and return an unsigned variant to
 * ensure duk_uint32_t casts back and forth nicely.  Almost everything
 * else uses the signed one.
 */
typedef duk_int_t duk_codepoint_t;
typedef duk_uint_t duk_ucodepoint_t;
#define DUK_CODEPOINT_MIN         DUK_INT_MIN
#define DUK_CODEPOINT_MAX         DUK_INT_MAX
#define DUK_UCODEPOINT_MIN        DUK_UINT_MIN
#define DUK_UCODEPOINT_MAX        DUK_UINT_MAX

/* IEEE float/double typedef. */
typedef float duk_float_t;
typedef double duk_double_t;

/* We're generally assuming that we're working on a platform with a 32-bit
 * address space.  If DUK_SIZE_MAX is a typecast value (which is necessary
 * if SIZE_MAX is missing), the check must be avoided because the
 * preprocessor can't do a comparison.
 */
#if !defined(DUK_SIZE_MAX)
#error DUK_SIZE_MAX is undefined, probably missing SIZE_MAX
#elif !defined(DUK_SIZE_MAX_COMPUTED)
#if DUK_SIZE_MAX < 0xffffffffUL
/* On some systems SIZE_MAX can be smaller than max unsigned 32-bit value
 * which seems incorrect if size_t is (at least) an unsigned 32-bit type.
 * However, it doesn't seem useful to error out compilation if this is the
 * case.
 */
#endif
#endif

/* Type used in public API declarations and user code.  Typedef maps to
 * 'struct duk_hthread' like the 'duk_hthread' typedef which is used
 * exclusively in internals.
 */
typedef struct duk_hthread duk_context;

/* Check whether we should use 64-bit integers or not.
 *
 * Quite incomplete now.  Use 64-bit types if detected (C99 or other detection)
 * unless they are known to be unreliable.  For instance, 64-bit types are
 * available on VBCC but seem to misbehave.
 */
#if defined(DUK_F_HAVE_64BIT) && !defined(DUK_F_VBCC)
#define DUK_USE_64BIT_OPS
#else
#undef DUK_USE_64BIT_OPS
#endif

/*
 *  Fill-ins for platform, architecture, and compiler
 */

/* An abort()-like primitive is needed by the default fatal error handler. */
#if !defined(DUK_ABORT)
#define DUK_ABORT             abort
#endif

#if !defined(DUK_SETJMP)
#define DUK_JMPBUF_TYPE       jmp_buf
#define DUK_SETJMP(jb)        setjmp((jb))
#define DUK_LONGJMP(jb)       longjmp((jb), 1)
#endif

#if 0
/* sigsetjmp() alternative */
#define DUK_JMPBUF_TYPE       sigjmp_buf
#define DUK_SETJMP(jb)        sigsetjmp((jb))
#define DUK_LONGJMP(jb)       siglongjmp((jb), 1)
#endif

/* Special naming to avoid conflict with e.g. DUK_FREE() in duk_heap.h
 * (which is unfortunately named).  May sometimes need replacement, e.g.
 * some compilers don't handle zero length or NULL correctly in realloc().
 */
#if !defined(DUK_ANSI_MALLOC)
#define DUK_ANSI_MALLOC      malloc
#endif
#if !defined(DUK_ANSI_REALLOC)
#define DUK_ANSI_REALLOC     realloc
#endif
#if !defined(DUK_ANSI_CALLOC)
#define DUK_ANSI_CALLOC      calloc
#endif
#if !defined(DUK_ANSI_FREE)
#define DUK_ANSI_FREE        free
#endif

/* ANSI C (various versions) and some implementations require that the
 * pointer arguments to memset(), memcpy(), and memmove() be valid values
 * even when byte size is 0 (even a NULL pointer is considered invalid in
 * this context).  Zero-size operations as such are allowed, as long as their
 * pointer arguments point to a valid memory area.  The DUK_MEMSET(),
 * DUK_MEMCPY(), and DUK_MEMMOVE() macros require this same behavior, i.e.:
 * (1) pointers must be valid and non-NULL, (2) zero size must otherwise be
 * allowed.  If these are not fulfilled, a macro wrapper is needed.
 *
 *   http://stackoverflow.com/questions/5243012/is-it-guaranteed-to-be-safe-to-perform-memcpy0-0-0
 *   http://lists.cs.uiuc.edu/pipermail/llvmdev/2007-October/011065.html
 *
 * Not sure what's the required behavior when a pointer points just past the
 * end of a buffer, which often happens in practice (e.g. zero size memmoves).
 * For example, if allocation size is 3, the following pointer would not
 * technically point to a valid memory byte:
 *
 *   <-- alloc -->
 *   | 0 | 1 | 2 | .....
 *                 ^-- p=3, points after last valid byte (2)
 */
#if !defined(DUK_MEMCPY)
#if defined(DUK_F_UCLIBC)
/* Old uclibcs have a broken memcpy so use memmove instead (this is overly wide
 * now on purpose): http://lists.uclibc.org/pipermail/uclibc-cvs/2008-October/025511.html
 */
#define DUK_MEMCPY       memmove
#else
#define DUK_MEMCPY       memcpy
#endif
#endif
#if !defined(DUK_MEMMOVE)
#define DUK_MEMMOVE      memmove
#endif
#if !defined(DUK_MEMCMP)
#define DUK_MEMCMP       memcmp
#endif
#if !defined(DUK_MEMSET)
#define DUK_MEMSET       memset
#endif
#if !defined(DUK_STRLEN)
#define DUK_STRLEN       strlen
#endif
#if !defined(DUK_STRCMP)
#define DUK_STRCMP       strcmp
#endif
#if !defined(DUK_STRNCMP)
#define DUK_STRNCMP      strncmp
#endif
#if !defined(DUK_SPRINTF)
#define DUK_SPRINTF      sprintf
#endif
#if !defined(DUK_SNPRINTF)
/* snprintf() is technically not part of C89 but usually available. */
#define DUK_SNPRINTF     snprintf
#endif
#if !defined(DUK_VSPRINTF)
#define DUK_VSPRINTF     vsprintf
#endif
#if !defined(DUK_VSNPRINTF)
/* vsnprintf() is technically not part of C89 but usually available. */
#define DUK_VSNPRINTF    vsnprintf
#endif
#if !defined(DUK_SSCANF)
#define DUK_SSCANF       sscanf
#endif
#if !defined(DUK_VSSCANF)
#define DUK_VSSCANF      vsscanf
#endif
#if !defined(DUK_MEMZERO)
#define DUK_MEMZERO(p,n) DUK_MEMSET((p), 0, (n))
#endif

#if !defined(DUK_DOUBLE_INFINITY)
#undef DUK_USE_COMPUTED_INFINITY
#if defined(DUK_F_GCC_VERSION) && (DUK_F_GCC_VERSION < 40600)
/* GCC older than 4.6: avoid overflow warnings related to using INFINITY */
#define DUK_DOUBLE_INFINITY  (__builtin_inf())
#elif defined(INFINITY)
#define DUK_DOUBLE_INFINITY  ((double) INFINITY)
#elif !defined(DUK_F_VBCC) && !defined(DUK_F_MSVC) && !defined(DUK_F_BCC) && \
      !defined(DUK_F_OLD_SOLARIS) && !defined(DUK_F_AIX)
#define DUK_DOUBLE_INFINITY  (1.0 / 0.0)
#else
/* In VBCC (1.0 / 0.0) results in a warning and 0.0 instead of infinity.
 * Use a computed infinity (initialized when a heap is created at the
 * latest).
 */
#define DUK_USE_COMPUTED_INFINITY
#define DUK_DOUBLE_INFINITY  duk_computed_infinity
#endif
#endif

#if !defined(DUK_DOUBLE_NAN)
#undef DUK_USE_COMPUTED_NAN
#if defined(NAN)
#define DUK_DOUBLE_NAN       NAN
#elif !defined(DUK_F_VBCC) && !defined(DUK_F_MSVC) && !defined(DUK_F_BCC) && \
      !defined(DUK_F_OLD_SOLARIS) && !defined(DUK_F_AIX)
#define DUK_DOUBLE_NAN       (0.0 / 0.0)
#else
/* In VBCC (0.0 / 0.0) results in a warning and 0.0 instead of NaN.
 * In MSVC (VS2010 Express) (0.0 / 0.0) results in a compile error.
 * Use a computed NaN (initialized when a heap is created at the
 * latest).
 */
#define DUK_USE_COMPUTED_NAN
#define DUK_DOUBLE_NAN       duk_computed_nan
#endif
#endif

/* Many platforms are missing fpclassify() and friends, so use replacements
 * if necessary.  The replacement constants (FP_NAN etc) can be anything but
 * match Linux constants now.
 */
#undef DUK_USE_REPL_FPCLASSIFY
#undef DUK_USE_REPL_SIGNBIT
#undef DUK_USE_REPL_ISFINITE
#undef DUK_USE_REPL_ISNAN
#undef DUK_USE_REPL_ISINF

/* Complex condition broken into separate parts. */
#undef DUK_F_USE_REPL_ALL
#if !(defined(FP_NAN) && defined(FP_INFINITE) && defined(FP_ZERO) && \
      defined(FP_SUBNORMAL) && defined(FP_NORMAL))
/* Missing some obvious constants. */
#define DUK_F_USE_REPL_ALL
#elif defined(DUK_F_AMIGAOS) && defined(DUK_F_VBCC)
/* VBCC is missing the built-ins even in C99 mode (perhaps a header issue). */
#define DUK_F_USE_REPL_ALL
#elif defined(DUK_F_AMIGAOS) && defined(DUK_F_M68K)
/* AmigaOS + M68K seems to have math issues even when using GCC cross
 * compilation.  Use replacements for all AmigaOS versions on M68K
 * regardless of compiler.
 */
#define DUK_F_USE_REPL_ALL
#elif defined(DUK_F_FREEBSD) && defined(DUK_F_CLANG)
/* Placeholder fix for (detection is wider than necessary):
 * http://llvm.org/bugs/show_bug.cgi?id=17788
 */
#define DUK_F_USE_REPL_ALL
#elif defined(DUK_F_UCLIBC)
/* At least some uclibc versions have broken floating point math.  For
 * example, fpclassify() can incorrectly classify certain NaN formats.
 * To be safe, use replacements.
 */
#define DUK_F_USE_REPL_ALL
#elif defined(DUK_F_AIX)
/* Older versions may be missing isnan(), etc. */
#define DUK_F_USE_REPL_ALL
#endif

#if defined(DUK_F_USE_REPL_ALL)
#define DUK_USE_REPL_FPCLASSIFY
#define DUK_USE_REPL_SIGNBIT
#define DUK_USE_REPL_ISFINITE
#define DUK_USE_REPL_ISNAN
#define DUK_USE_REPL_ISINF
#define DUK_FPCLASSIFY       duk_repl_fpclassify
#define DUK_SIGNBIT          duk_repl_signbit
#define DUK_ISFINITE         duk_repl_isfinite
#define DUK_ISNAN            duk_repl_isnan
#define DUK_ISINF            duk_repl_isinf
#define DUK_FP_NAN           0
#define DUK_FP_INFINITE      1
#define DUK_FP_ZERO          2
#define DUK_FP_SUBNORMAL     3
#define DUK_FP_NORMAL        4
#else
#define DUK_FPCLASSIFY       fpclassify
#define DUK_SIGNBIT          signbit
#define DUK_ISFINITE         isfinite
#define DUK_ISNAN            isnan
#define DUK_ISINF            isinf
#define DUK_FP_NAN           FP_NAN
#define DUK_FP_INFINITE      FP_INFINITE
#define DUK_FP_ZERO          FP_ZERO
#define DUK_FP_SUBNORMAL     FP_SUBNORMAL
#define DUK_FP_NORMAL        FP_NORMAL
#endif

#if defined(DUK_F_USE_REPL_ALL)
#undef DUK_F_USE_REPL_ALL
#endif

/* These functions don't currently need replacement but are wrapped for
 * completeness.  Because these are used as function pointers, they need
 * to be defined as concrete C functions (not macros).
 */
#if !defined(DUK_FABS)
#define DUK_FABS             fabs
#endif
#if !defined(DUK_FLOOR)
#define DUK_FLOOR            floor
#endif
#if !defined(DUK_CEIL)
#define DUK_CEIL             ceil
#endif
#if !defined(DUK_FMOD)
#define DUK_FMOD             fmod
#endif
#if !defined(DUK_POW)
#define DUK_POW              pow
#endif
#if !defined(DUK_ACOS)
#define DUK_ACOS             acos
#endif
#if !defined(DUK_ASIN)
#define DUK_ASIN             asin
#endif
#if !defined(DUK_ATAN)
#define DUK_ATAN             atan
#endif
#if !defined(DUK_ATAN2)
#define DUK_ATAN2            atan2
#endif
#if !defined(DUK_SIN)
#define DUK_SIN              sin
#endif
#if !defined(DUK_COS)
#define DUK_COS              cos
#endif
#if !defined(DUK_TAN)
#define DUK_TAN              tan
#endif
#if !defined(DUK_EXP)
#define DUK_EXP              exp
#endif
#if !defined(DUK_LOG)
#define DUK_LOG              log
#endif
#if !defined(DUK_SQRT)
#define DUK_SQRT             sqrt
#endif

/* The functions below exist only in C99/C++11 or later and need a workaround
 * for platforms that don't include them.  MSVC isn't detected as C99, but
 * these functions also exist in MSVC 2013 and later so include a clause for
 * that too.  Android doesn't have log2; disable all of these for Android.
 */
#if (defined(DUK_F_C99) || defined(DUK_F_CPP11) || (defined(_MSC_VER) && (_MSC_VER >= 1800))) && \
    !defined(DUK_F_ANDROID) && !defined(DUK_F_MINT)
#if !defined(DUK_CBRT)
#define DUK_CBRT             cbrt
#endif
#if !defined(DUK_LOG2)
#define DUK_LOG2             log2
#endif
#if !defined(DUK_LOG10)
#define DUK_LOG10            log10
#endif
#if !defined(DUK_TRUNC)
#define DUK_TRUNC            trunc
#endif
#endif  /* DUK_F_C99 etc */

/* NetBSD 6.0 x86 (at least) has a few problems with pow() semantics,
 * see test-bug-netbsd-math-pow.js.  MinGW has similar (but different)
 * issues, see test-bug-mingw-math-issues.js.  Enable pow() workarounds
 * for these targets.
 */
#undef DUK_USE_POW_WORKAROUNDS
#if defined(DUK_F_NETBSD) || defined(DUK_F_MINGW)
#define DUK_USE_POW_WORKAROUNDS
#endif

/* Similar workarounds for atan2() semantics issues.  MinGW issues are
 * documented in test-bug-mingw-math-issues.js.
 */
#undef DUK_USE_ATAN2_WORKAROUNDS
#if defined(DUK_F_MINGW)
#define DUK_USE_ATAN2_WORKAROUNDS
#endif

/* Rely as little as possible on compiler behavior for NaN comparison,
 * signed zero handling, etc.  Currently never activated but may be needed
 * for broken compilers.
 */
#undef DUK_USE_PARANOID_MATH

/* There was a curious bug where test-bi-date-canceling.js would fail e.g.
 * on 64-bit Ubuntu, gcc-4.8.1, -m32, and no -std=c99.  Some date computations
 * using doubles would be optimized which then broke some corner case tests.
 * The problem goes away by adding 'volatile' to the datetime computations.
 * Not sure what the actual triggering conditions are, but using this on
 * non-C99 systems solves the known issues and has relatively little cost
 * on other platforms.
 */
#undef DUK_USE_PARANOID_DATE_COMPUTATION
#if !defined(DUK_F_C99)
#define DUK_USE_PARANOID_DATE_COMPUTATION
#endif

/*
 *  Alignment requirement and support for unaligned accesses
 *
 *  Assume unaligned accesses are not supported unless specifically allowed
 *  in the target platform.  Some platforms may support unaligned accesses
 *  but alignment to 4 or 8 may still be desirable.  Note that unaligned
 *  accesses (and even pointers) relative to natural alignment (regardless
 *  of target alignment) are technically undefined behavior and thus
 *  compiler/architecture specific.
 */

/* If not forced, use safe default for alignment. */
#if !defined(DUK_USE_ALIGN_BY)
#define DUK_USE_ALIGN_BY 8
#endif

/* Compiler specific hackery needed to force struct size to match aligment,
 * see e.g. duk_hbuffer.h.
 *
 * http://stackoverflow.com/questions/11130109/c-struct-size-alignment
 * http://stackoverflow.com/questions/10951039/specifying-64-bit-alignment
 */
#if !(defined(DUK_USE_PACK_MSVC_PRAGMA) || defined(DUK_USE_PACK_GCC_ATTR) || \
      defined(DUK_USE_PACK_CLANG_ATTR) || defined(DUK_USE_PACK_DUMMY_MEMBER))
#define DUK_USE_PACK_DUMMY_MEMBER
#endif

#if !defined(DUK_VA_COPY)
/* We need va_copy() which is defined in C99 / C++11, so an awkward
 * replacement is needed for pre-C99 / pre-C++11 environments.  This
 * will quite likely need portability hacks for some non-C99
 * environments.
 */
#if defined(DUK_F_C99) || defined(DUK_F_CPP11)
/* C99 / C++11 and above: rely on va_copy() which is required.
 * Omit parenthesis on macro right side on purpose to minimize differences
 * to direct use.
 */
#define DUK_VA_COPY(dest,src) va_copy(dest,src)
#else
/* Pre-C99: va_list type is implementation dependent.  This replacement
 * assumes it is a plain value so that a simple assignment will work.
 * This is not the case on all platforms (it may be a single-array element,
 * for instance).
 */
#define DUK_VA_COPY(dest,src) do { (dest) = (src); } while (0)
#endif
#endif

#if !defined(DUK_MACRO_STRINGIFY)
/* Macro hackery to convert e.g. __LINE__ to a string without formatting,
 * see: http://stackoverflow.com/questions/240353/convert-a-preprocessor-token-to-a-string
 */
#define DUK_MACRO_STRINGIFY_HELPER(x)  #x
#define DUK_MACRO_STRINGIFY(x)  DUK_MACRO_STRINGIFY_HELPER(x)
#endif

#if !defined(DUK_CAUSE_SEGFAULT)
/* This can be used for testing; valgrind will then indicate the C call stack
 * leading to the call site.
 */
#define DUK_CAUSE_SEGFAULT()  do { *((volatile duk_uint32_t *) NULL) = (duk_uint32_t) 0xdeadbeefUL; } while (0)
#endif

#if !defined(DUK_UNREF)
/* Macro for suppressing warnings for potentially unreferenced variables.
 * The variables can be actually unreferenced or unreferenced in some
 * specific cases only; for instance, if a variable is only debug printed,
 * it is unreferenced when debug printing is disabled.  May cause warnings
 * for volatile arguments.
 */
#define DUK_UNREF(x)  do { (void) (x); } while (0)
#endif

/* Fillin for DUK_NORETURN; DUK_WO_NORETURN() is used to insert dummy
 * dummy statements after noreturn calls to silence harmless compiler
 * warnings, e.g.:
 *
 *   DUK_ERROR_TYPE(thr, "aiee");
 *   DUK_WO_NORETURN(return 0;);
 *
 * Statements inside DUK_WO_NORETURN() must NEVER be actually reachable,
 * and they're only included to satisfy the compiler.
 */
#if defined(DUK_NORETURN)
#define DUK_WO_NORETURN(stmt) do { } while (0)
#else
#define DUK_NORETURN(decl)  decl
#define DUK_WO_NORETURN(stmt) do { stmt } while (0)
#endif

#if !defined(DUK_UNREACHABLE)
/* Don't know how to declare unreachable point, so don't do it; this
 * may cause some spurious compilation warnings (e.g. "variable used
 * uninitialized").
 */
#define DUK_UNREACHABLE()  do { } while (0)
#endif

#if !defined(DUK_LOSE_CONST)
/* Convert any input pointer into a "void *", losing a const qualifier.
 * This is not fully portable because casting through duk_uintptr_t may
 * not work on all architectures (e.g. those with long, segmented pointers).
 */
#define DUK_LOSE_CONST(src) ((void *) (duk_uintptr_t) (src))
#endif

#if !defined(DUK_LIKELY)
#define DUK_LIKELY(x)    (x)
#endif
#if !defined(DUK_UNLIKELY)
#define DUK_UNLIKELY(x)  (x)
#endif
#if !defined(DUK_UNPREDICTABLE)
#define DUK_UNPREDICTABLE(x)  (x)
#endif

#if !defined(DUK_NOINLINE)
#define DUK_NOINLINE       /*nop*/
#endif
#if !defined(DUK_INLINE)
#define DUK_INLINE         /*nop*/
#endif
#if !defined(DUK_ALWAYS_INLINE)
#define DUK_ALWAYS_INLINE  /*nop*/
#endif

#if !defined(DUK_HOT)
#define DUK_HOT            /*nop*/
#endif
#if !defined(DUK_COLD)
#define DUK_COLD           /*nop*/
#endif

#if !defined(DUK_EXTERNAL_DECL)
#define DUK_EXTERNAL_DECL  extern
#endif
#if !defined(DUK_EXTERNAL)
#define DUK_EXTERNAL       /*empty*/
#endif
#if !defined(DUK_INTERNAL_DECL)
#if defined(DUK_SINGLE_FILE)
#define DUK_INTERNAL_DECL  static
#else
#define DUK_INTERNAL_DECL  extern
#endif
#endif
#if !defined(DUK_INTERNAL)
#if defined(DUK_SINGLE_FILE)
#define DUK_INTERNAL       static
#else
#define DUK_INTERNAL       /*empty*/
#endif
#endif
#if !defined(DUK_LOCAL_DECL)
#define DUK_LOCAL_DECL     static
#endif
#if !defined(DUK_LOCAL)
#define DUK_LOCAL          static
#endif

#if !defined(DUK_FILE_MACRO)
#define DUK_FILE_MACRO  __FILE__
#endif
#if !defined(DUK_LINE_MACRO)
#define DUK_LINE_MACRO  __LINE__
#endif
#if !defined(DUK_FUNC_MACRO)
#if defined(DUK_F_C99) || defined(DUK_F_CPP11)
#define DUK_FUNC_MACRO  __func__
#elif defined(__FUNCTION__)
#define DUK_FUNC_MACRO  __FUNCTION__
#else
#define DUK_FUNC_MACRO  "unknown"
#endif
#endif

#if !defined(DUK_BSWAP32)
#define DUK_BSWAP32(x) \
	((((duk_uint32_t) (x)) >> 24) | \
	 ((((duk_uint32_t) (x)) >> 8) & 0xff00UL) | \
	 ((((duk_uint32_t) (x)) << 8) & 0xff0000UL) | \
	 (((duk_uint32_t) (x)) << 24))
#endif
#if !defined(DUK_BSWAP16)
#define DUK_BSWAP16(x) \
	((duk_uint16_t) (x) >> 8) | \
	((duk_uint16_t) (x) << 8)
#endif

/* DUK_USE_VARIADIC_MACROS: required from compilers, so no fill-in. */
/* DUK_USE_UNION_INITIALIZERS: required from compilers, so no fill-in. */

#if !(defined(DUK_USE_FLEX_C99) || defined(DUK_USE_FLEX_ZEROSIZE) || defined(DUK_USE_FLEX_ONESIZE))
#if defined(DUK_F_C99)
#define DUK_USE_FLEX_C99
#else
#define DUK_USE_FLEX_ZEROSIZE  /* Not standard but common enough */
#endif
#endif

#if !(defined(DUK_USE_PACK_GCC_ATTR) || defined(DUK_USE_PACK_CLANG_ATTR) || \
      defined(DUK_USE_PACK_MSVC_PRAGMA) || defined(DUK_USE_PACK_DUMMY_MEMBER))
#define DUK_USE_PACK_DUMMY_MEMBER
#endif

#if 0  /* not defined by default */
#undef DUK_USE_GCC_PRAGMAS
#endif

#if !defined(DUK_U64_CONSTANT)
#define DUK_U64_CONSTANT(x) x##ULL
#endif
#if !defined(DUK_I64_CONSTANT)
#define DUK_I64_CONSTANT(x) x##LL
#endif

/* Workaround for GH-323: avoid inlining control when compiling from
 * multiple sources, as it causes compiler portability trouble.
 */
#if !defined(DUK_SINGLE_FILE)
#undef DUK_NOINLINE
#undef DUK_INLINE
#undef DUK_ALWAYS_INLINE
#define DUK_NOINLINE       /*nop*/
#define DUK_INLINE         /*nop*/
#define DUK_ALWAYS_INLINE  /*nop*/
#endif

/* Object property allocation layout has implications for memory and code
 * footprint and generated code size/speed.  The best layout also depends
 * on whether the platform has alignment requirements or benefits from
 * having mostly aligned accesses.
 */
#undef DUK_USE_HOBJECT_LAYOUT_1
#undef DUK_USE_HOBJECT_LAYOUT_2
#undef DUK_USE_HOBJECT_LAYOUT_3
#if (DUK_USE_ALIGN_BY == 1)
/* On platforms without any alignment issues, layout 1 is preferable
 * because it compiles to slightly less code and provides direct access
 * to property keys.
 */
#define DUK_USE_HOBJECT_LAYOUT_1
#else
/* On other platforms use layout 2, which requires some padding but
 * is a bit more natural than layout 3 in ordering the entries.  Layout
 * 3 is currently not used.
 */
#define DUK_USE_HOBJECT_LAYOUT_2
#endif

/* GCC/clang inaccurate math would break compliance and probably duk_tval,
 * so refuse to compile.  Relax this if -ffast-math is tested to work.
 */
#if defined(__FAST_MATH__)
#error __FAST_MATH__ defined, refusing to compile
#endif

/*
 *  Autogenerated defaults
 */

#undef DUK_USE_ALLOW_UNDEFINED_BEHAVIOR
#define DUK_USE_ARRAY_BUILTIN
#define DUK_USE_ARRAY_FASTPATH
#define DUK_USE_ARRAY_PROP_FASTPATH
#undef DUK_USE_ASSERTIONS
#define DUK_USE_AUGMENT_ERROR_CREATE
#define DUK_USE_AUGMENT_ERROR_THROW
#define DUK_USE_AVOID_PLATFORM_FUNCPTRS
#define DUK_USE_BASE64_FASTPATH
#define DUK_USE_BASE64_SUPPORT
#define DUK_USE_BOOLEAN_BUILTIN
#define DUK_USE_BUFFEROBJECT_SUPPORT
#undef DUK_USE_BUFLEN16
#define DUK_USE_BYTECODE_DUMP_SUPPORT
#define DUK_USE_CACHE_ACTIVATION
#define DUK_USE_CACHE_CATCHER
#define DUK_USE_CALLSTACK_LIMIT 10000
#define DUK_USE_COMMONJS_MODULES
#define DUK_USE_COMPILER_RECLIMIT 2500
#define DUK_USE_COROUTINE_SUPPORT
#undef DUK_USE_CPP_EXCEPTIONS
#undef DUK_USE_DATAPTR16
#undef DUK_USE_DATAPTR_DEC16
#undef DUK_USE_DATAPTR_ENC16
#define DUK_USE_DATE_BUILTIN
#undef DUK_USE_DATE_FMT_STRFTIME
#undef DUK_USE_DATE_FORMAT_STRING
#undef DUK_USE_DATE_GET_LOCAL_TZOFFSET
#undef DUK_USE_DATE_GET_NOW
#undef DUK_USE_DATE_NOW_GETTIMEOFDAY
#undef DUK_USE_DATE_NOW_TIME
#undef DUK_USE_DATE_PARSE_STRING
#undef DUK_USE_DATE_PRS_GETDATE
#undef DUK_USE_DATE_PRS_STRPTIME
#undef DUK_USE_DATE_TZO_GMTIME
#undef DUK_USE_DATE_TZO_GMTIME_R
#undef DUK_USE_DATE_TZO_GMTIME_S
#undef DUK_USE_DATE_TZO_WINDOWS_NO_DST
#undef DUK_USE_DEBUG
#undef DUK_USE_DEBUGGER_DUMPHEAP
#undef DUK_USE_DEBUGGER_INSPECT
#undef DUK_USE_DEBUGGER_PAUSE_UNCAUGHT
#undef DUK_USE_DEBUGGER_SUPPORT
#define DUK_USE_DEBUGGER_THROW_NOTIFY
#undef DUK_USE_DEBUGGER_TRANSPORT_TORTURE
#define DUK_USE_DEBUG_BUFSIZE 65536L
#define DUK_USE_DEBUG_LEVEL 0
#undef DUK_USE_DEBUG_WRITE
#define DUK_USE_DOUBLE_LINKED_HEAP
#define DUK_USE_DUKTAPE_BUILTIN
#define DUK_USE_ENCODING_BUILTINS
#define DUK_USE_ERRCREATE
#define DUK_USE_ERRTHROW
#define DUK_USE_ES6
#define DUK_USE_ES6_OBJECT_PROTO_PROPERTY
#define DUK_USE_ES6_OBJECT_SETPROTOTYPEOF
#define DUK_USE_ES6_PROXY
#define DUK_USE_ES6_REGEXP_SYNTAX
#define DUK_USE_ES6_UNICODE_ESCAPE
#define DUK_USE_ES7
#define DUK_USE_ES7_EXP_OPERATOR
#define DUK_USE_ES8
#define DUK_USE_ES9
#define DUK_USE_ESBC_LIMITS
#define DUK_USE_ESBC_MAX_BYTES 2147418112L
#define DUK_USE_ESBC_MAX_LINENUMBER 2147418112L
#undef DUK_USE_EXEC_FUN_LOCAL
#undef DUK_USE_EXEC_INDIRECT_BOUND_CHECK
#undef DUK_USE_EXEC_PREFER_SIZE
#define DUK_USE_EXEC_REGCONST_OPTIMIZE
#undef DUK_USE_EXEC_TIMEOUT_CHECK
#undef DUK_USE_EXPLICIT_NULL_INIT
#undef DUK_USE_EXTSTR_FREE
#undef DUK_USE_EXTSTR_INTERN_CHECK
#undef DUK_USE_FASTINT
#define DUK_USE_FAST_REFCOUNT_DEFAULT
#undef DUK_USE_FATAL_HANDLER
#define DUK_USE_FATAL_MAXLEN 128
#define DUK_USE_FINALIZER_SUPPORT
#undef DUK_USE_FINALIZER_TORTURE
#undef DUK_USE_FUNCPTR16
#undef DUK_USE_FUNCPTR_DEC16
#undef DUK_USE_FUNCPTR_ENC16
#define DUK_USE_FUNCTION_BUILTIN
#define DUK_USE_FUNC_FILENAME_PROPERTY
#define DUK_USE_FUNC_NAME_PROPERTY
#undef DUK_USE_GC_TORTURE
#undef DUK_USE_GET_MONOTONIC_TIME
#undef DUK_USE_GET_MONOTONIC_TIME_CLOCK_GETTIME
#undef DUK_USE_GET_RANDOM_DOUBLE
#undef DUK_USE_GLOBAL_BINDING
#define DUK_USE_GLOBAL_BUILTIN
#undef DUK_USE_HEAPPTR16
#undef DUK_USE_HEAPPTR_DEC16
#undef DUK_USE_HEAPPTR_ENC16
#define DUK_USE_HEX_FASTPATH
#define DUK_USE_HEX_SUPPORT
#define DUK_USE_HOBJECT_ARRAY_ABANDON_LIMIT 2
#define DUK_USE_HOBJECT_ARRAY_FAST_RESIZE_LIMIT 9
#define DUK_USE_HOBJECT_ARRAY_MINGROW_ADD 16
#define DUK_USE_HOBJECT_ARRAY_MINGROW_DIVISOR 8
#define DUK_USE_HOBJECT_ENTRY_MINGROW_ADD 16
#define DUK_USE_HOBJECT_ENTRY_MINGROW_DIVISOR 8
#define DUK_USE_HOBJECT_HASH_PART
#define DUK_USE_HOBJECT_HASH_PROP_LIMIT 8
#define DUK_USE_HSTRING_ARRIDX
#define DUK_USE_HSTRING_CLEN
#undef DUK_USE_HSTRING_EXTDATA
#define DUK_USE_HSTRING_LAZY_CLEN
#define DUK_USE_HTML_COMMENTS
#define DUK_USE_IDCHAR_FASTPATH
#undef DUK_USE_INJECT_HEAP_ALLOC_ERROR
#undef DUK_USE_INTERRUPT_COUNTER
#undef DUK_USE_INTERRUPT_DEBUG_FIXUP
#define DUK_USE_JC
#define DUK_USE_JSON_BUILTIN
#define DUK_USE_JSON_DECNUMBER_FASTPATH
#define DUK_USE_JSON_DECSTRING_FASTPATH
#define DUK_USE_JSON_DEC_RECLIMIT 1000
#define DUK_USE_JSON_EATWHITE_FASTPATH
#define DUK_USE_JSON_ENC_RECLIMIT 1000
#define DUK_USE_JSON_QUOTESTRING_FASTPATH
#undef DUK_USE_JSON_STRINGIFY_FASTPATH
#define DUK_USE_JSON_SUPPORT
#define DUK_USE_JX
#define DUK_USE_LEXER_SLIDING_WINDOW
#undef DUK_USE_LIGHTFUNC_BUILTINS
#define DUK_USE_LITCACHE_SIZE 256
#define DUK_USE_MARK_AND_SWEEP_RECLIMIT 256
#define DUK_USE_MATH_BUILTIN
#define DUK_USE_NATIVE_CALL_RECLIMIT 1000
#define DUK_USE_NONSTD_ARRAY_SPLICE_DELCOUNT
#undef DUK_USE_NONSTD_FUNC_CALLER_PROPERTY
#undef DUK_USE_NONSTD_FUNC_SOURCE_PROPERTY
#define DUK_USE_NONSTD_FUNC_STMT
#define DUK_USE_NONSTD_GETTER_KEY_ARGUMENT
#define DUK_USE_NONSTD_JSON_ESC_U2028_U2029
#define DUK_USE_NONSTD_SETTER_KEY_ARGUMENT
#define DUK_USE_NONSTD_STRING_FROMCHARCODE_32BIT
#define DUK_USE_NUMBER_BUILTIN
#define DUK_USE_OBJECT_BUILTIN
#undef DUK_USE_OBJSIZES16
#undef DUK_USE_PACK_CLANG_ATTR
#undef DUK_USE_PACK_GCC_ATTR
#undef DUK_USE_PARANOID_ERRORS
#define DUK_USE_PC2LINE
#define DUK_USE_PERFORMANCE_BUILTIN
#undef DUK_USE_PREFER_SIZE
#undef DUK_USE_PROMISE_BUILTIN
#define DUK_USE_PROVIDE_DEFAULT_ALLOC_FUNCTIONS
#undef DUK_USE_REFCOUNT16
#define DUK_USE_REFCOUNT32
#define DUK_USE_REFERENCE_COUNTING
#define DUK_USE_REFLECT_BUILTIN
#define DUK_USE_REGEXP_CANON_BITMAP
#undef DUK_USE_REGEXP_CANON_WORKAROUND
#define DUK_USE_REGEXP_COMPILER_RECLIMIT 10000
#define DUK_USE_REGEXP_EXECUTOR_RECLIMIT 10000
#define DUK_USE_REGEXP_SUPPORT
#undef DUK_USE_ROM_GLOBAL_CLONE
#undef DUK_USE_ROM_GLOBAL_INHERIT
#undef DUK_USE_ROM_OBJECTS
#define DUK_USE_ROM_PTRCOMP_FIRST 63488L
#undef DUK_USE_ROM_STRINGS
#define DUK_USE_SECTION_B
#undef DUK_USE_SELF_TESTS
#define DUK_USE_SHEBANG_COMMENTS
#undef DUK_USE_SHUFFLE_TORTURE
#define DUK_USE_SOURCE_NONBMP
#undef DUK_USE_STRHASH16
#undef DUK_USE_STRHASH_DENSE
#define DUK_USE_STRHASH_SKIP_SHIFT 5
#define DUK_USE_STRICT_DECL
#undef DUK_USE_STRICT_UTF8_SOURCE
#define DUK_USE_STRING_BUILTIN
#undef DUK_USE_STRLEN16
#define DUK_USE_STRTAB_GROW_LIMIT 17
#define DUK_USE_STRTAB_MAXSIZE 268435456L
#define DUK_USE_STRTAB_MINSIZE 1024
#undef DUK_USE_STRTAB_PTRCOMP
#define DUK_USE_STRTAB_RESIZE_CHECK_MASK 255
#define DUK_USE_STRTAB_SHRINK_LIMIT 6
#undef DUK_USE_STRTAB_TORTURE
#undef DUK_USE_SYMBOL_BUILTIN
#define DUK_USE_TAILCALL
#define DUK_USE_TARGET_INFO "unknown"
#define DUK_USE_TRACEBACKS
#define DUK_USE_TRACEBACK_DEPTH 10
#define DUK_USE_USER_DECLARE() /* no user declarations */
#define DUK_USE_VALSTACK_GROW_SHIFT 2
#define DUK_USE_VALSTACK_LIMIT 1000000L
#define DUK_USE_VALSTACK_SHRINK_CHECK_SHIFT 2
#define DUK_USE_VALSTACK_SHRINK_SLACK_SHIFT 4
#undef DUK_USE_VALSTACK_UNSAFE
#define DUK_USE_VERBOSE_ERRORS
#define DUK_USE_VERBOSE_EXECUTOR_ERRORS
#define DUK_USE_VOLUNTARY_GC
#define DUK_USE_ZERO_BUFFER_DATA

/*
 *  You may add overriding #define/#undef directives below for
 *  customization.  You of course cannot un-#include or un-typedef
 *  anything; these require direct changes above.
 */

/* __OVERRIDE_DEFINES__ */

/*
 *  Conditional includes
 */

#if defined(DUK_F_CPP) && defined(DUK_USE_CPP_EXCEPTIONS)
#include <exception>  /* std::exception */
#include <stdexcept>  /* std::runtime_error */
#endif

/*
 *  Date provider selection
 *
 *  User may define DUK_USE_DATE_GET_NOW() etc directly, in which case we'll
 *  rely on an external provider.  If this is not done, revert to previous
 *  behavior and use Unix/Windows built-in provider.
 */

#if defined(DUK_COMPILING_DUKTAPE)

#if defined(DUK_USE_DATE_GET_NOW)
/* External provider already defined. */
#elif defined(DUK_USE_DATE_NOW_GETTIMEOFDAY)
#define DUK_USE_DATE_GET_NOW(ctx)            duk_bi_date_get_now_gettimeofday()
#elif defined(DUK_USE_DATE_NOW_TIME)
#define DUK_USE_DATE_GET_NOW(ctx)            duk_bi_date_get_now_time()
#elif defined(DUK_USE_DATE_NOW_WINDOWS)
#define DUK_USE_DATE_GET_NOW(ctx)            duk_bi_date_get_now_windows()
#elif defined(DUK_USE_DATE_NOW_WINDOWS_SUBMS)
#define DUK_USE_DATE_GET_NOW(ctx)            duk_bi_date_get_now_windows_subms()
#else
#error no provider for DUK_USE_DATE_GET_NOW()
#endif

#if defined(DUK_USE_DATE_GET_LOCAL_TZOFFSET)
/* External provider already defined. */
#elif defined(DUK_USE_DATE_TZO_GMTIME_R) || defined(DUK_USE_DATE_TZO_GMTIME_S) || defined(DUK_USE_DATE_TZO_GMTIME)
#define DUK_USE_DATE_GET_LOCAL_TZOFFSET(d)   duk_bi_date_get_local_tzoffset_gmtime((d))
#elif defined(DUK_USE_DATE_TZO_WINDOWS)
#define DUK_USE_DATE_GET_LOCAL_TZOFFSET(d)   duk_bi_date_get_local_tzoffset_windows((d))
#elif defined(DUK_USE_DATE_TZO_WINDOWS_NO_DST)
#define DUK_USE_DATE_GET_LOCAL_TZOFFSET(d)   duk_bi_date_get_local_tzoffset_windows_no_dst((d))
#else
#error no provider for DUK_USE_DATE_GET_LOCAL_TZOFFSET()
#endif

#if defined(DUK_USE_DATE_PARSE_STRING)
/* External provider already defined. */
#elif defined(DUK_USE_DATE_PRS_STRPTIME)
#define DUK_USE_DATE_PARSE_STRING(ctx,str)   duk_bi_date_parse_string_strptime((ctx), (str))
#elif defined(DUK_USE_DATE_PRS_GETDATE)
#define DUK_USE_DATE_PARSE_STRING(ctx,str)   duk_bi_date_parse_string_getdate((ctx), (str))
#else
/* No provider for DUK_USE_DATE_PARSE_STRING(), fall back to ISO 8601 only. */
#endif

#if defined(DUK_USE_DATE_FORMAT_STRING)
/* External provider already defined. */
#elif defined(DUK_USE_DATE_FMT_STRFTIME)
#define DUK_USE_DATE_FORMAT_STRING(ctx,parts,tzoffset,flags) \
	duk_bi_date_format_parts_strftime((ctx), (parts), (tzoffset), (flags))
#else
/* No provider for DUK_USE_DATE_FORMAT_STRING(), fall back to ISO 8601 only. */
#endif

#if defined(DUK_USE_GET_MONOTONIC_TIME)
/* External provider already defined. */
#elif defined(DUK_USE_GET_MONOTONIC_TIME_CLOCK_GETTIME)
#define DUK_USE_GET_MONOTONIC_TIME(ctx)  duk_bi_date_get_monotonic_time_clock_gettime()
#elif defined(DUK_USE_GET_MONOTONIC_TIME_WINDOWS_QPC)
#define DUK_USE_GET_MONOTONIC_TIME(ctx)  duk_bi_date_get_monotonic_time_windows_qpc()
#else
/* No provider for DUK_USE_GET_MONOTONIC_TIME(), fall back to DUK_USE_DATE_GET_NOW(). */
#endif

#endif  /* DUK_COMPILING_DUKTAPE */

/*
 *  Convert DUK_USE_BYTEORDER, from whatever source, into currently used
 *  internal defines.  If detection failed, #error out.
 */

#if defined(DUK_USE_BYTEORDER)
#if (DUK_USE_BYTEORDER == 1)
#define DUK_USE_INTEGER_LE
#define DUK_USE_DOUBLE_LE
#elif (DUK_USE_BYTEORDER == 2)
#define DUK_USE_INTEGER_LE  /* integer endianness is little on purpose */
#define DUK_USE_DOUBLE_ME
#elif (DUK_USE_BYTEORDER == 3)
#define DUK_USE_INTEGER_BE
#define DUK_USE_DOUBLE_BE
#else
#error unsupported: byte order invalid
#endif  /* byte order */
#else
#error unsupported: byte order detection failed
#endif  /* defined(DUK_USE_BYTEORDER) */

#endif  /* DUK_CONFIG_H_INCLUDED */

#define DUK_ASC_NUL 0x00
#define DUK_ASC_SOH 0x01
#define DUK_ASC_STX 0x02
#define DUK_ASC_ETX 0x03
#define DUK_ASC_EOT 0x04
#define DUK_ASC_ENQ 0x05
#define DUK_ASC_ACK 0x06
#define DUK_ASC_BEL 0x07
#define DUK_ASC_BS 0x08
#define DUK_ASC_HT 0x09
#define DUK_ASC_LF 0x0a
#define DUK_ASC_VT 0x0b
#define DUK_ASC_FF 0x0c
#define DUK_ASC_CR 0x0d
#define DUK_ASC_SO 0x0e
#define DUK_ASC_SI 0x0f
#define DUK_ASC_DLE 0x10
#define DUK_ASC_DC1 0x11
#define DUK_ASC_DC2 0x12
#define DUK_ASC_DC3 0x13
#define DUK_ASC_DC4 0x14
#define DUK_ASC_NAK 0x15
#define DUK_ASC_SYN 0x16
#define DUK_ASC_ETB 0x17
#define DUK_ASC_CAN 0x18
#define DUK_ASC_EM 0x19
#define DUK_ASC_SUB 0x1a
#define DUK_ASC_ESC 0x1b
#define DUK_ASC_FS 0x1c
#define DUK_ASC_GS 0x1d
#define DUK_ASC_RS 0x1e
#define DUK_ASC_US 0x1f
#define DUK_ASC_SPACE 0x20
#define DUK_ASC_EXCLAMATION 0x21
#define DUK_ASC_DOUBLEQUOTE 0x22
#define DUK_ASC_HASH 0x23
#define DUK_ASC_DOLLAR 0x24
#define DUK_ASC_PERCENT 0x25
#define DUK_ASC_AMP 0x26
#define DUK_ASC_SINGLEQUOTE 0x27
#define DUK_ASC_LPAREN 0x28
#define DUK_ASC_RPAREN 0x29
#define DUK_ASC_STAR 0x2a
#define DUK_ASC_PLUS 0x2b
#define DUK_ASC_COMMA 0x2c
#define DUK_ASC_MINUS 0x2d
#define DUK_ASC_PERIOD 0x2e
#define DUK_ASC_SLASH 0x2f
#define DUK_ASC_0 0x30
#define DUK_ASC_1 0x31
#define DUK_ASC_2 0x32
#define DUK_ASC_3 0x33
#define DUK_ASC_4 0x34
#define DUK_ASC_5 0x35
#define DUK_ASC_6 0x36
#define DUK_ASC_7 0x37
#define DUK_ASC_8 0x38
#define DUK_ASC_9 0x39
#define DUK_ASC_COLON 0x3a
#define DUK_ASC_SEMICOLON 0x3b
#define DUK_ASC_LANGLE 0x3c
#define DUK_ASC_EQUALS 0x3d
#define DUK_ASC_RANGLE 0x3e
#define DUK_ASC_QUESTION 0x3f
#define DUK_ASC_ATSIGN 0x40
#define DUK_ASC_UC_A 0x41
#define DUK_ASC_UC_B 0x42
#define DUK_ASC_UC_C 0x43
#define DUK_ASC_UC_D 0x44
#define DUK_ASC_UC_E 0x45
#define DUK_ASC_UC_F 0x46
#define DUK_ASC_UC_G 0x47
#define DUK_ASC_UC_H 0x48
#define DUK_ASC_UC_I 0x49
#define DUK_ASC_UC_J 0x4a
#define DUK_ASC_UC_K 0x4b
#define DUK_ASC_UC_L 0x4c
#define DUK_ASC_UC_M 0x4d
#define DUK_ASC_UC_N 0x4e
#define DUK_ASC_UC_O 0x4f
#define DUK_ASC_UC_P 0x50
#define DUK_ASC_UC_Q 0x51
#define DUK_ASC_UC_R 0x52
#define DUK_ASC_UC_S 0x53
#define DUK_ASC_UC_T 0x54
#define DUK_ASC_UC_U 0x55
#define DUK_ASC_UC_V 0x56
#define DUK_ASC_UC_W 0x57
#define DUK_ASC_UC_X 0x58
#define DUK_ASC_UC_Y 0x59
#define DUK_ASC_UC_Z 0x5a
#define DUK_ASC_LBRACKET 0x5b
#define DUK_ASC_BACKSLASH 0x5c
#define DUK_ASC_RBRACKET 0x5d
#define DUK_ASC_CARET 0x5e
#define DUK_ASC_UNDERSCORE 0x5f
#define DUK_ASC_GRAVE 0x60
#define DUK_ASC_LC_A 0x61
#define DUK_ASC_LC_B 0x62
#define DUK_ASC_LC_C 0x63
#define DUK_ASC_LC_D 0x64
#define DUK_ASC_LC_E 0x65
#define DUK_ASC_LC_F 0x66
#define DUK_ASC_LC_G 0x67
#define DUK_ASC_LC_H 0x68
#define DUK_ASC_LC_I 0x69
#define DUK_ASC_LC_J 0x6a
#define DUK_ASC_LC_K 0x6b
#define DUK_ASC_LC_L 0x6c
#define DUK_ASC_LC_M 0x6d
#define DUK_ASC_LC_N 0x6e
#define DUK_ASC_LC_O 0x6f
#define DUK_ASC_LC_P 0x70
#define DUK_ASC_LC_Q 0x71
#define DUK_ASC_LC_R 0x72
#define DUK_ASC_LC_S 0x73
#define DUK_ASC_LC_T 0x74
#define DUK_ASC_LC_U 0x75
#define DUK_ASC_LC_V 0x76
#define DUK_ASC_LC_W 0x77
#define DUK_ASC_LC_X 0x78
#define DUK_ASC_LC_Y 0x79
#define DUK_ASC_LC_Z 0x7a
#define DUK_ASC_LCURLY 0x7b
#define DUK_ASC_PIPE 0x7c
#define DUK_ASC_RCURLY 0x7d
#define DUK_ASC_TILDE 0x7e
#define DUK_ASC_DEL 0x7f
namespace pogo {
    struct lexer_ctx {
        int position = {};
        bool eof     = {};
        std::string buffer;
        std::string output;
        std::vector<std::string> tokens;
        std::vector<int> token_types;

        int lookup(int p_position) {
            auto r_position = position + p_position;
            if (r_position < 0 || r_position >= buffer.size()) return 0;
            return buffer[r_position];
        }

        void advance(int count) {
            position += count;
            // fuck it, let it advence past the valid end.
            // if (position >= buffer.size()) position = buffer.size() - 1;
            if (position >= buffer.size()) eof = true;
        }

        void append(int character) { output += character; }
        void new_token(int token_type) {
            if (!output.empty()) {
                tokens.emplace_back(std::move(output));
                token_types.emplace_back(token_type);
                output = std::string();
            }
        }
    };

#define DUK_DDD(x)
#define DUK_ASSERT(x)
#define DUK__L0() DUK__LOOKUP(lex_ctx, 0)
#define DUK__L1() DUK__LOOKUP(lex_ctx, 1)
#define DUK__L2() DUK__LOOKUP(lex_ctx, 2)
#define DUK__L3() DUK__LOOKUP(lex_ctx, 3)
#define DUK__L4() DUK__LOOKUP(lex_ctx, 4)
#define DUK__L5() DUK__LOOKUP(lex_ctx, 5)
/* Regexp tokens */
#define DUK_RETOK_EOF 0
#define DUK_RETOK_DISJUNCTION 1
#define DUK_RETOK_QUANTIFIER 2
#define DUK_RETOK_ASSERT_START 3
#define DUK_RETOK_ASSERT_END 4
#define DUK_RETOK_ASSERT_WORD_BOUNDARY 5
#define DUK_RETOK_ASSERT_NOT_WORD_BOUNDARY 6
#define DUK_RETOK_ASSERT_START_POS_LOOKAHEAD 7
#define DUK_RETOK_ASSERT_START_NEG_LOOKAHEAD 8
#define DUK_RETOK_ATOM_PERIOD 9
#define DUK_RETOK_ATOM_CHAR 10
#define DUK_RETOK_ATOM_DIGIT 11         /* assumptions in regexp compiler */
#define DUK_RETOK_ATOM_NOT_DIGIT 12     /* -""- */
#define DUK_RETOK_ATOM_WHITE 13         /* -""- */
#define DUK_RETOK_ATOM_NOT_WHITE 14     /* -""- */
#define DUK_RETOK_ATOM_WORD_CHAR 15     /* -""- */
#define DUK_RETOK_ATOM_NOT_WORD_CHAR 16 /* -""- */
#define DUK_RETOK_ATOM_BACKREFERENCE 17
#define DUK_RETOK_ATOM_START_CAPTURE_GROUP 18
#define DUK_RETOK_ATOM_START_NONCAPTURE_GROUP 19
#define DUK_RETOK_ATOM_START_CHARCLASS 20
#define DUK_RETOK_ATOM_START_CHARCLASS_INVERTED 21
#define DUK_RETOK_ATOM_END_GROUP 22

#define DUK__ISDIGIT(x) ((x) >= DUK_ASC_0 && (x) <= DUK_ASC_9)
#define DUK__ISHEXDIGIT(x) duk__is_hex_digit((x))
#define DUK__ISOCTDIGIT(x) ((x) >= DUK_ASC_0 && (x) <= DUK_ASC_7)
#define DUK__ISDIGIT03(x) ((x) >= DUK_ASC_0 && (x) <= DUK_ASC_3)
#define DUK__ISDIGIT47(x) ((x) >= DUK_ASC_4 && (x) <= DUK_ASC_7)

#define DUK__LOOKUP(lex_ctx, idx) ((lex_ctx).lookup(idx))
#define DUK__ADVANCECHARS(lex_ctx, count) ((lex_ctx).advance(count))
#define DUK__ADVANCEBYTES(lex_ctx, count) ((lex_ctx).advance(count))
#define DUK__INITBUFFER(lex_ctx) duk__initbuffer((lex_ctx))
#define DUK__APPENDBUFFER(lex_ctx, x) ((lex_ctx).append(x))
#define DUK__APPENDBUFFER_ASCII(lex_ctx, x) ((lex_ctx).append(x))
/* Constants for lexer_ctx.buf. */
#define DUK_LEXER_TEMP_BUF_LIMIT 256
#define DUK_LEXER_WINDOW_SIZE 6
#if defined(DUK_USE_LEXER_SLIDING_WINDOW)
#define DUK_LEXER_BUFFER_SIZE 64
#endif
    /* A token value.  Can be memcpy()'d, but note that slot1/slot2 values are on the valstack.
     * Some fields (like num, str1, str2) are only valid for specific token types and may have
     * stale values otherwise.
     */
#define DUK_RE_QUANTIFIER_INFINITE ((duk_uint32_t)0xffffffffUL)

    /* A regexp token value. */
    struct duk_re_token {
        int t; /* token type */
        int greedy;
        duk_uint32_t num; /* numeric value (character, count) */
        duk_uint32_t qmin;
        duk_uint32_t qmax;
    };

    /* A structure for 'snapshotting' a point for rewinding */
    struct duk_lexer_point {
        duk_size_t offset;
        duk_int_t line;
    };

    /* Lexer codepoint with additional info like offset/line number */
    struct duk_lexer_codepoint {
        int codepoint;
        duk_size_t offset;
        duk_int_t line;
    };

    /* Lexer context.  Same context is used for ECMAScript and Regexp parsing. */

    /*
     *  Prototypes
     */

    DUK_INTERNAL_DECL
#if defined(DUK_USE_REGEXP_SUPPORT)
#endif /* DUK_USE_REGEXP_SUPPORT */

    /* #include duk_js_compiler.h */
    /*
     *  ECMAScript compiler.
     */

#define DUK_JS_COMPILER_H_INCLUDED

/* ECMAScript compiler limits */
#define DUK_COMPILER_TOKEN_LIMIT 100000000L /* 1e8: protects against deeply nested inner functions */

/* maximum loopcount for peephole optimization */
#define DUK_COMPILER_PEEPHOLE_MAXITER 3

/* maximum bytecode length in instructions */
#define DUK_COMPILER_MAX_BYTECODE_LENGTH (256L * 1024L * 1024L) /* 1 GB */

    /*
     *  Compiler intermediate values
     *
     *  Intermediate values describe either plain values (e.g. strings or
     *  numbers) or binary operations which have not yet been coerced into
     *  either a left-hand-side or right-hand-side role (e.g. object property).
     */

#define DUK_IVAL_NONE 0  /* no value */
#define DUK_IVAL_PLAIN 1 /* register, constant, or value */
#define DUK_IVAL_ARITH 2 /* binary arithmetic; DUK_OP_ADD, DUK_OP_EQ, other binary ops */
#define DUK_IVAL_PROP 3  /* property access */
#define DUK_IVAL_VAR 4   /* variable access */

#define DUK_ISPEC_NONE 0     /* no value */
#define DUK_ISPEC_VALUE 1    /* value resides in 'valstack_idx' */
#define DUK_ISPEC_REGCONST 2 /* value resides in a register or constant */

/* Bit mask which indicates that a regconst is a constant instead of a register.
 * Chosen so that when a regconst is cast to duk_int32_t, all consts are
 * negative values.
 */
#define DUK_REGCONST_CONST_MARKER DUK_INT32_MIN /* = -0x80000000 */

    /* Type to represent a reg/const reference during compilation, with <0
     * indicating a constant.  Some call sites also use -1 to indicate 'none'.
     */

    /*
     *  Bytecode instruction representation during compilation
     *
     *  Contains the actual instruction and (optionally) debug info.
     */

    /*
     *  Compiler state
     */

#define DUK_LABEL_FLAG_ALLOW_BREAK (1U << 0)
#define DUK_LABEL_FLAG_ALLOW_CONTINUE (1U << 1)

#define DUK_DECL_TYPE_VAR 0
#define DUK_DECL_TYPE_FUNC 1

    /*
     *  Append a Unicode codepoint to the temporary byte buffer.  Performs
     *  CESU-8 surrogate pair encoding for codepoints above the BMP.
     *  Existing surrogate pairs are allowed and also encoded into CESU-8.
     */

    /*
     *  Init lexer context
     */

    DUK_INTERNAL const duk_int8_t duk_hex_dectab[256] = {
        /* -1 if invalid */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x00-0x0f */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x10-0x1f */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x20-0x2f */
        0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, /* 0x30-0x3f */
        -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x40-0x4f */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x50-0x5f */
        -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x60-0x6f */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x70-0x7f */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x80-0x8f */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x90-0x9f */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xa0-0xaf */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xb0-0xbf */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xc0-0xcf */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xd0-0xdf */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xe0-0xef */
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1  /* 0xf0-0xff */
    };

    /*
     *  Lexing helpers
     */

    /* Numeric value of a hex digit (also covers octal and decimal digits) or
     * -1 if not a valid hex digit.
     */
    DUK_LOCAL int duk__hexval_validate(int x) {
        int t;

        /* Here 'x' is a Unicode codepoint */
        if (DUK_LIKELY(x >= 0 && x <= 0xff)) {
            t = duk_hex_dectab[x];
            if (DUK_LIKELY(t >= 0)) {
                return t;
            }
        }

        return -1;
    }

    /* Just a wrapper for call sites where 'x' is known to be valid so
     * we assert for it before decoding.
     */
    DUK_LOCAL int duk__hexval(int x) {
        int ret;

        DUK_ASSERT((x >= DUK_ASC_0 && x <= DUK_ASC_9) || (x >= DUK_ASC_LC_A && x <= DUK_ASC_LC_F) ||
                   (x >= DUK_ASC_UC_A && x <= DUK_ASC_UC_F));
        ret = duk__hexval_validate(x);
        DUK_ASSERT(ret >= 0 && ret <= 15);
        return ret;
    }

    /* having this as a separate function provided a size benefit */
    DUK_LOCAL bool duk__is_hex_digit(int x) {
        if (DUK_LIKELY(x >= 0 && x <= 0xff)) {
            return (duk_hex_dectab[x] >= 0);
        }
        return 0;
    }

    /* Parse a Unicode escape of the form \xHH, \uHHHH, or \u{H+}.  Shared by
     * source and RegExp parsing.
     */
    DUK_LOCAL int duk__lexer_parse_escape(lexer_ctx& lex_ctx, bool allow_es6) {
        int digits; /* Initial value 2 or 4 for fixed length escapes, 0 for ES2015 \u{H+}. */
        int escval;
        int x;
        int adv;

        DUK_ASSERT(DUK__L0() == DUK_ASC_BACKSLASH); /* caller responsibilities */
        DUK_ASSERT(DUK__L1() == DUK_ASC_LC_X || DUK__L1() == DUK_ASC_LC_U);
        DUK_UNREF(allow_es6);

        adv    = 2;
        digits = 2;
        if (DUK__L1() == DUK_ASC_LC_U) {
            digits = 4;
#if defined(DUK_USE_ES6_UNICODE_ESCAPE)
            if (DUK__L2() == DUK_ASC_LCURLY && allow_es6) {
                digits = 0;
                adv    = 3;
            }
#endif
        }
        DUK__ADVANCECHARS(lex_ctx, adv);

        escval = 0;
        for (;;) {
            /* One of the escape forms: \xHH, \uHHHH, \u{H+}.
             * The 'digits' variable tracks parsing state and is
             * initialized to:
             *
             *   \xHH     2
             *   \uHH     4
             *   \u{H+}   0 first time, updated to -1 to indicate
             *            at least one digit has been parsed
             *
             * Octal parsing is handled separately because it can be
             * done with fixed lookahead and also has validation
             * rules which depend on the escape length (which is
             * variable).
             *
             * We don't need a specific check for x < 0 (end of
             * input) or duk_unicode_is_line_terminator(x)
             * because the 'dig' decode will fail and lead to a
             * SyntaxError.
             */
            int dig;

            x = DUK__L0();
            DUK__ADVANCECHARS(lex_ctx, 1);

            dig = duk__hexval_validate(x);
            if (digits > 0) {
                digits--;
                if (dig < 0) {
                    goto fail_escape;
                }
                DUK_ASSERT(dig >= 0x00 && dig <= 0x0f);
                escval = (escval << 4) + dig;
                if (digits == 0) {
                    DUK_ASSERT(escval >= 0 && escval <= 0xffffL);
                    break;
                }
            } else {
#if defined(DUK_USE_ES6_UNICODE_ESCAPE)
                DUK_ASSERT(digits == 0 /* first time */ || digits == -1 /* others */);
                if (dig >= 0) {
                    DUK_ASSERT(dig >= 0x00 && dig <= 0x0f);
                    escval = (escval << 4) + dig;
                    if (escval > 0x10ffffL) {
                        goto fail_escape;
                    }
                } else if (x == DUK_ASC_RCURLY) {
                    if (digits == 0) {
                        /* Empty escape, \u{}. */
                        goto fail_escape;
                    }
                    DUK_ASSERT(escval >= 0 && escval <= 0x10ffffL);
                    break;
                } else {
                    goto fail_escape;
                }
                digits = -1; /* Indicate we have at least one digit. */
#else                        /* DUK_USE_ES6_UNICODE_ESCAPE */
                DUK_ASSERT(0); /* Never happens if \u{H+} support disabled. */
#endif                       /* DUK_USE_ES6_UNICODE_ESCAPE */
            }
        }

        return escval;

    fail_escape:
        throw std::runtime_error("DUK_STR_INVALID_ESCAPE");
        DUK_WO_NORETURN(return 0;);
    }

    /* Parse legacy octal escape of the form \N{1,3}, e.g. \0, \5, \0377.  Maximum
     * allowed value is \0377 (U+00FF), longest match is used.  Used for both string
     * RegExp octal escape parsing.  Window[0] must be the slash '\' and the first
     * digit must already be validated to be in [0-9] by the caller.
     */

    bool duk_unicode_is_line_terminator(duk_int_t cp) {
        /*
         *  E5 Section 7.3
         *
         *  A LineTerminatorSequence essentially merges <CR> <LF> sequences
         *  into a single line terminator.  This must be handled by the caller.
         */

        if (cp == 0x000aL || cp == 0x000dL || cp == 0x2028L || cp == 0x2029L) {
            return 1;
        }

        return 0;
    }

/* lexer character window helpers */

/* lookup shorthands (note: assume context variable is named 'lex_ctx') */
#undef DUK_UNREF
#define DUK_UNREF(x) \
    do {             \
        (void)(x);   \
    } while (0)
    /* Parse a Unicode escape of the form \xHH, \uHHHH, or \u{H+}.  Shared by
     * source and RegExp parsing.
     */

    DUK_LOCAL duk_codepoint_t duk__lexer_parse_legacy_octal(lexer_ctx& lex_ctx, int* out_adv, duk_bool_t reject_annex_b) {
        duk_codepoint_t cp;
        int lookup_idx;
        int adv;
        duk_codepoint_t tmp;

        DUK_ASSERT(out_adv != NULL);
        DUK_ASSERT(DUK__LOOKUP(lex_ctx, 0) == DUK_ASC_BACKSLASH);
        DUK_ASSERT(DUK__LOOKUP(lex_ctx, 1) >= DUK_ASC_0 && DUK__LOOKUP(lex_ctx, 1) <= DUK_ASC_9);

        cp  = 0;
        tmp = 0;
        for (lookup_idx = 1; lookup_idx <= 3; lookup_idx++) {
            tmp = DUK__LOOKUP(lex_ctx, lookup_idx);
            if (tmp < DUK_ASC_0 || tmp > DUK_ASC_7) {
                /* No more valid digits. */
                break;
            }
            tmp = (cp << 3) + (tmp - DUK_ASC_0);
            if (tmp > 0xff) {
                /* Three digit octal escapes above \377 (= 0xff)
                 * are not allowed.
                 */
                break;
            }
            cp = tmp;
        }
        DUK_DDD(DUK_DDDPRINT("final lookup_idx=%ld, cp=%ld", (long)lookup_idx, (long)cp));

        adv = lookup_idx;
        if (lookup_idx == 1) {
            DUK_DDD(DUK_DDDPRINT("\\8 or \\9 -> treat as literal, accept in strict mode too"));
            DUK_ASSERT(tmp == DUK_ASC_8 || tmp == DUK_ASC_9);
            cp = tmp;
            adv++; /* correction to above, eat offending character */
        } else if (lookup_idx == 2 && cp == 0) {
            /* Note: 'foo\0bar' is OK in strict mode, but 'foo\00bar' is not.
             * It won't be interpreted as 'foo\u{0}0bar' but as a SyntaxError.
             */
            DUK_DDD(DUK_DDDPRINT("\\0 -> accept in strict mode too"));
        } else {
            /* This clause also handles non-shortest zero, e.g. \00. */
            if (reject_annex_b) {
                DUK_DDD(DUK_DDDPRINT("non-zero octal literal %ld -> reject in strict-mode", (long)cp));
                cp = -1;
            } else {
                DUK_DDD(DUK_DDDPRINT("non-zero octal literal %ld -> accepted", (long)cp));
                DUK_ASSERT(cp >= 0 && cp <= 0xff);
            }
        }

        *out_adv = adv;

        DUK_ASSERT((cp >= 0 && cp <= 0xff) || (cp == -1 && reject_annex_b));
        return cp;
    }

    /* XXX: move strict mode to lex_ctx? */
    DUK_LOCAL void duk__lexer_parse_string_literal(lexer_ctx& lex_ctx, int quote, bool strict_mode) {
        int adv;

        for (adv = 1 /* initial quote */;;) {
            int x;

            DUK__ADVANCECHARS(lex_ctx, adv); /* eat opening quote on first loop */
            x = DUK__L0();

            adv = 1;
            if (x == quote) {
                DUK__ADVANCECHARS(lex_ctx, 1); /* eat closing quote */
                break;
            }
            if (x == '\\') {
                /* DUK__L0        -> '\' char
                 * DUK__L1 ... DUK__L5 -> more lookup
                 */
                int emitcp = -1;

                x = DUK__L1();

                /* How much to advance before next loop. */
                adv = 2; /* note: long live range */

                switch (x) {
                    case '\'': emitcp = 0x0027; break;
                    case '"': emitcp = 0x0022; break;
                    case '\\': emitcp = 0x005c; break;
                    case 'b': emitcp = 0x0008; break;
                    case 'f': emitcp = 0x000c; break;
                    case 'n': emitcp = 0x000a; break;
                    case 'r': emitcp = 0x000d; break;
                    case 't': emitcp = 0x0009; break;
                    case 'v': emitcp = 0x000b; break;
                    case 'x':
                    case 'u': {
                        int esc_cp;
                        esc_cp = duk__lexer_parse_escape(lex_ctx, 1 /*allow_es6*/);
                        DUK__APPENDBUFFER(lex_ctx, esc_cp);
                        adv = 0;
                        break;
                    }
                    default: {
                        if (duk_unicode_is_line_terminator(x)) {
                            /* line continuation */
                            if (x == 0x000d && DUK__L2() == 0x000a) {
                                /* CR LF again a special case */
                                adv = 3; /* line terminator, CR, LF */
                            }
                        } else if (DUK__ISDIGIT(x)) {
                            /*
                             *  Octal escape or zero escape:
                             *    \0                                     (lookahead not OctalDigit)
                             *    \1 ... \7                              (lookahead not OctalDigit)
                             *    \ZeroToThree OctalDigit                (lookahead not OctalDigit)
                             *    \FourToSeven OctalDigit                (no lookahead restrictions)
                             *    \ZeroToThree OctalDigit OctalDigit     (no lookahead restrictions)
                             *
                             *  Zero escape is part of the standard syntax.  Octal escapes are
                             *  defined in E5 Section B.1.2, and are only allowed in non-strict mode.
                             *  Any other productions starting with a decimal digit are invalid
                             *  but are in practice treated like identity escapes.
                             *
                             *  Parse octal (up to 3 digits) from the lookup window.
                             */

                            emitcp = duk__lexer_parse_legacy_octal(lex_ctx, &adv, strict_mode /*reject_annex_b*/);
                            if (emitcp < 0) {
                                goto fail_escape;
                            }
                        } else if (x < 0) {
                            goto fail_unterminated;
                        } else {
                            /* escaped NonEscapeCharacter */
                            DUK__APPENDBUFFER(lex_ctx, x);
                        }
                    } /* end default clause */
                }     /* end switch */

                /* Shared handling for single codepoint escapes. */
                if (emitcp >= 0) {
                    DUK__APPENDBUFFER(lex_ctx, emitcp);
                }
            } else if (x >= 0x20 && x <= 0x7f) {
                /* Fast path for ASCII case, avoids line terminator
                 * check and CESU-8 encoding.
                 */
                DUK_ASSERT(x >= 0);
                DUK_ASSERT(!duk_unicode_is_line_terminator(x));
                DUK_ASSERT(x != quote);
                DUK_ASSERT(x != DUK_ASC_BACKSLASH);
                DUK__APPENDBUFFER_ASCII(lex_ctx, x);
            } else if (x <= 0 || duk_unicode_is_line_terminator(x)) {
                goto fail_unterminated;
            } else {
                /* Character which is part of the string but wasn't handled
                 * by the fast path.
                 */
                DUK__APPENDBUFFER(lex_ctx, x);
            }
        } /* string parse loop */

        return;

    fail_escape:
        throw std::runtime_error("DUK_STR_INVALID_ESCAPE");
        DUK_WO_NORETURN(return;);

    fail_unterminated:
        throw std::runtime_error("DUK_STR_UNTERMINATED_STRING");
        DUK_WO_NORETURN(return;);
    }

    /* Skip to end-of-line (or end-of-file), used for single line comments. */
    DUK_LOCAL void duk__lexer_skip_to_endofline(lexer_ctx& lex_ctx) {
        for (;;) {
            int x;

            x = DUK__L0();
            if (x < 0 || duk_unicode_is_line_terminator(x)) {
                break;
            }
            DUK__ADVANCECHARS(lex_ctx, 1);
        }
    }

    DUK_LOCAL lexer_ctx duk__lexer_parse_line(std::string line, bool strict_mode) {
        lexer_ctx lex_ctx;
        lex_ctx.buffer = std::move(line);

        int x;
        while (!lex_ctx.eof && ((x = DUK__L0()))) {
            LOG_TRACE(__FUNCTION__ ": %i/%i", lex_ctx.position, x);
            switch (x) {
                case DUK_ASC_SPACE:
                    lex_ctx.new_token(0);
                    DUK__ADVANCECHARS(lex_ctx, 1);
                    continue;
                case DUK_ASC_DOUBLEQUOTE:
                    duk__lexer_parse_string_literal(lex_ctx, x, false);
                    lex_ctx.new_token(1);
                    continue;
                default: lex_ctx.append(x); DUK__ADVANCECHARS(lex_ctx, 1);
            }
        }
        lex_ctx.new_token(0);
        return lex_ctx;
    }

    void WhitespaceTokeniser::parse(const std::string& cs) {
        auto lex_ctx = duk__lexer_parse_line(cs, false);
        int i        = 0;
        for (auto tok : lex_ctx.tokens) {
            m_tokens.emplace_back(std::move(tok));
            m_token_types.emplace_back((enum token_types_t)lex_ctx.token_types[i]);
            ++i;
        }
    }

}  // namespace pogo
